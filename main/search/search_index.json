{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Home","text":""},{"location":"#overview","title":"Overview","text":"<p>A Python library for general purpose object factories. In particular, it focuses on dynamic object factory implementations where objects can be registered dynamically without changing the code of the factory. An object factory can be used to instantiate an object from its configuration. The current implementation contains both abstract factory and registry approaches.</p> <p>factory</p> <pre><code>from objectory import factory\n\n\nclass MyClass:\n    pass\n\n\nobj = factory(\"MyClass\")\nprint(obj)\n</code></pre> <p>abstract factory</p> <pre><code>from objectory import AbstractFactory\n\n\nclass BaseClass(metaclass=AbstractFactory):\n    pass\n\n\nclass MyClass(BaseClass):\n    pass\n\n\nobj = BaseClass.factory(\"MyClass\")\nprint(obj)\n</code></pre> <p>Output:</p> <pre><code>&lt;__main__.MyClass object at 0x...&gt;\n</code></pre> <p>registry</p> <pre><code>from objectory import Registry\n\nregistry = Registry()\n\n\n@registry.register()\nclass MyClass:\n    pass\n\n\nobj = registry.factory(\"MyClass\")\nprint(obj)\n</code></pre> <pre><code>&lt;__main__.MyClass object at 0x...&gt;\n</code></pre>"},{"location":"#api-stability","title":"API stability","text":"<p> While <code>objectory</code> is in development stage, no API is guaranteed to be stable from one release to the next. In fact, it is very likely that the API will change multiple times before a stable 1.0.0 release. In practice, this means that upgrading <code>objectory</code> to a new version will possibly break any code that was using the old version of <code>objectory</code>.</p>"},{"location":"#license","title":"License","text":"<p><code>objectory</code> is licensed under BSD 3-Clause \"New\" or \"Revised\" license available in LICENSE file.</p>"},{"location":"abstract_factory/","title":"Abstract Factory","text":"<p>This page presents the <code>AbstractFactory</code> metaclass which implement an abstract factory design pattern. The abstract factory is a creational design pattern that lets you produce families of related objects without specifying their concrete classes. This design pattern is also known as \"Factory of Factories\" because it is a \"super-factory\" which creates other factories. This metaclass proposes an implementation for creating a factory of related objects without explicitly specifying their classes. Each generated factory can instantiate the objects as per the Factory pattern.</p>"},{"location":"abstract_factory/#create-a-factory","title":"Create a factory","text":"<p>The <code>AbstractFactory</code> metaclass is not a factory, but it contains the blueprint on how to build a factory. To create a factory, you will define a base class. This class is used to register the other classes but also to define the common interface of the factory. In the following of the documentation, we will call this class the base factory class. The example below shows the minimal implementation of a base class:</p> <pre><code>from objectory import AbstractFactory\n\n\nclass BaseClass(metaclass=AbstractFactory):\n    pass\n</code></pre> <p>The base class should inherit the <code>AbstractFactory</code> metaclass. This metaclass will implement the factory mechanism to the base class. The base class can implement functions and attributes like a regular python class. It can also be an abstract class or not.</p>"},{"location":"abstract_factory/#register-an-object","title":"Register an object","text":"<p>This section explains the basics on how to register an object to a factory. It is possible to register a function. This section assumes you already created a factory as explained above. There are two approaches to register an object to the factory:</p> <ul> <li>by using the inheritance (only for class)</li> <li>by using the <code>register_object</code> function (both class and function)</li> </ul>"},{"location":"abstract_factory/#inheritance","title":"Inheritance","text":"<p>The recommended approach to register a class to the factory is to use the inheritance. Every time that you create a new child class of the base factory class, the child class is automatically registered to the factory. For example, you can define the <code>Child1Class</code> class with the following implementation:</p> <pre><code>from objectory import AbstractFactory\n\n\nclass BaseClass(metaclass=AbstractFactory):\n    pass\n\n\nclass Child1Class(BaseClass):\n    pass\n</code></pre> <p>When the <code>Child1Class</code> class is created, it is automatically added to the <code>BaseClass</code> factory. The developer does not have to write any additional line to register the class. It is possible to define more complex child classes with a constructor or any functions/attributes. For example, you can define the <code>Child2Class</code> class with the following implementation:</p> <pre><code>class Child2Class(BaseClass):\n    def __init__(self, dim: int):\n        self.dim = dim\n</code></pre> <p>Similarly, any grand child class of the base factory class is automatically registered to the factory. In the following example, the <code>Child3Class</code> class which inherits from <code>Child1Class</code> class will be added to the <code>BaseClass</code> factory:</p> <pre><code>class Child3Class(Child1Class):\n    pass\n</code></pre>"},{"location":"abstract_factory/#register_object-function","title":"<code>register_object</code> function","text":"<p>The inheritance approach works when it is possible to modify the source code of the classes because each registered need to inherit from the base factory class. However, it is not possible to do that in particular when the code depends on a third party library. To overcome this limitation, it is possible to use the <code>register_object</code> function to manually register some classes that are defined outside the project.</p> <p>Let's take the example of PyTorch. PyTorch is an open source machine learning framework. To define a machine learning model in PyTorch, you can implement a new class that inherits from the <code>torch.nn.Module</code> class. PyTorch also provides many module implementations. If you want to build a factory that includes both your module implementations and the PyTorch ones, you can do it by using the inheritance and the <code>register_object</code> function. First, you need to define the base factory class:</p> <pre><code>import torch\nfrom objectory import AbstractFactory\n\n\nclass BaseModule(torch.nn.Module, metaclass=AbstractFactory):\n    pass\n\n\nclass MyModule1(BaseModule):\n    pass\n\n\nclass MyModule2(BaseModule):\n    pass\n</code></pre> <p>Then you can register some modules implemented in PyTorch. For example if you want to register the class <code>torch.nn.Linear</code> to the factory of <code>BaseModule</code>, you can write the following lines:</p> <pre><code>import torch\n\nBaseModule.register_object(torch.nn.Linear)\n</code></pre> <p>The <code>register_object</code> function can be used to register a class but also a function. To be consistent with the factory idea, you should only register functions that returns an object that is compatible with the common interface of the factory. Note that no warning will be raised if you do not follow this rule, but it will be your responsibility to manage this situation. Please keep in mind that with power comes responsibility. The following example shows how to register a function:</p> <pre><code>import torch\n\n\ndef my_nodule(input_size: int, output_size: int) -&gt; torch.nn.Module:\n    return torch.nn.Sequential(\n        torch.nn.Linear(input_size, 32),\n        torch.nn.ReLU(),\n        torch.nn.Linear(32, output_size),\n    )\n\n\nBaseModule.register_object(my_nodule)\n</code></pre> <p>Another approach to register a function is to use the decorator <code>register</code>:</p> <pre><code>import torch\nfrom objectory import register\n\n\n@register(BaseModule)\ndef my_nodule(input_size: int, output_size: int) -&gt; torch.nn.Module:\n    return torch.nn.Sequential(\n        torch.nn.Linear(input_size, 32),\n        torch.nn.ReLU(),\n        torch.nn.Linear(32, output_size),\n    )\n</code></pre> <p>The argument of the decorator is the base factory class where the function will be registered.</p> <p> It is not possible to register a lambda function. Please use a regular python function instead. The registry will raise the exception <code>IncorrectObjectFactoryError</code> if you try to register a lambda function.</p>"},{"location":"abstract_factory/#registered-objects","title":"Registered objects","text":""},{"location":"abstract_factory/#inheritors","title":"Inheritors","text":"<p>Sometimes it is important to know what are the registered objects to the factory. You can see the list of the objects that are registered to the base class by using the attribute <code>inheritors</code>. This attribute contains the full name of the class as well as the class. If you print the value of <code>inheritors</code>,</p> <pre><code>print(BaseClass.inheritors)\n</code></pre> <p>Output:</p> <pre><code>{\n  \"my_package.base.BaseClass\": &lt;class \"my_package.base.BaseClass\"&gt;,\n  \"my_package.child1.Child1Class\": &lt;class \"my_package.child1.Child1Class\"&gt;,\n  \"my_package.child2.Child2Class\": &lt;class \"my_package.child2.Child2Class\"&gt;,\n  \"my_package.child3.Child3Class\": &lt;class \"my_package.child3.Child3Class\"&gt;\n}\n</code></pre> <p>This example assumes that the <code>BaseClass</code> is written in the file <code>my_package/base.py</code> and <code>Child&lt;X&gt;Class</code> is written in the file <code>my_package/child&lt;X&gt;.py</code>.</p> <p>Note that the base class and all its children classes have the attribute <code>inheritors</code> so you can check the registered objects with any of these classes:</p> <pre><code>print(Child1Class.inheritors)\nprint(Child2Class.inheritors)\n</code></pre> <p>Output:</p> <pre><code>{\n  \"my_package.base.BaseClass\": &lt;class \"my_package.base.BaseClass\"&gt;,\n  \"my_package.child1.Child1Class\": &lt;class \"my_package.child1.Child1Class\"&gt;,\n  \"my_package.child2.Child2Class\": &lt;class \"my_package.child2.Child2Class\"&gt;,\n  \"my_package.child3.Child3Class\": &lt;class \"my_package.child3.Child3Class\"&gt;\n}\n{\n  \"my_package.base.BaseClass\": &lt;class \"my_package.base.BaseClass\"&gt;,\n  \"my_package.child1.Child1Class\": &lt;class \"my_package.child1.Child1Class\"&gt;,\n  \"my_package.child2.Child2Class\": &lt;class \"my_package.child2.Child2Class\"&gt;,\n  \"my_package.child3.Child3Class\": &lt;class \"my_package.child3.Child3Class\"&gt;\n}\n</code></pre> <p>The key of each object is the full name of the object. If you register two objects with the same full class name (package name + module name + class name), only the last object will be registered. It is the responsibility of the user to manage the object name to avoid duplicate.</p> <p>If you have registered some functions, you should see them in the inheritors. For example if you have registered the function <code>my_nodule</code> in the <code>BaseModule</code>, you should see something like: <code>'my_package.nodule.my_nodule': &lt;function my_nodule at 0x...&gt;</code>.</p>"},{"location":"abstract_factory/#missing-objects","title":"Missing objects","text":"<p>To be added to the factory, an object has to be loaded at least one time. The objects are automatically registered when they are loaded the first time. An object which is never loaded will never be registered. If you do not see an object in the list of inheritors, it is probably because it was not loaded. First, verify that the object inherits from the base factory class or the <code>register</code> function is called. Then, check if the python module with the object is loaded at least one time.</p> <p>A solution to this problem is to write the child classes in the same python module that the base factory class. However, this solution is not always good or possible. When there is a lot of objects, it is usually better to write them in several python modules.</p> <p>Let's assume the following situation where each class is written in a different python module. The package should have the following structure:</p> <pre><code>my_package/\n    __init__.py\n    base.py\n    child1.py\n    child2.py\n</code></pre> <p>A solution is to import the child classes in the <code>__init__.py</code>. The file <code>__init__.py</code> should have the following lines</p> <pre><code>from my_package import child1\nfrom my_package import child2\n</code></pre> <p>Another solution is to use the import package tool.</p>"},{"location":"abstract_factory/#factory","title":"Factory","text":"<p>This section explains how to instantiate dynamically a class registered in a <code>AbstractFactory</code>. One of the operation done by the <code>AbstractFactory</code> metaclass is to add the <code>factory</code> function to the base factory class and all its child classes. This function can instantiate any registered class given its configuration. The signature of the<code>factory</code> function is:</p> <pre><code>def factory(cls, _target_: str, *args, _init_: str = \"__init__\", **kwargs): ...\n</code></pre> <p>where <code>*args</code> and <code>**kwargs</code> are the parameters of the object to instantiate. The input <code>_target_</code> is used to define the name of the object to instantiate and <code>_init_</code> indicates the function used to create the object. The following sections will explain the role of each parameter and how to use them.</p>"},{"location":"abstract_factory/#target-object","title":"Target object","text":"<p>One of the key features of the <code>factory</code> function is that you can specify the name of the object that you want to instantiate. The <code>_target_</code> input is used to define the name of the object to instantiate. For example if you want to create an  <code>Child1Class</code> object, you can write:</p> <pre><code>my_obj = BaseClass.factory(\"my_package.child1.Child1Class\")\n</code></pre> <p>When you instantiate an object, you can also specify the arguments. For example if you want to create a <code>Child2Class</code> object with 10 layers, you can write:</p> <pre><code>my_obj = BaseClass.factory(\"my_package.child2.Child2Class\", num_layers=10)\n</code></pre> <p>Sometimes it can be time consuming to write the full class name. If the class name is unique, you can instantiate the object by only specifying the class name. In the previous example, instead of the full class name (<code>my_package.child1.Child1Class</code>) you can specify only the class name (<code>Child1Class</code>):</p> <pre><code>my_obj = BaseClass.factory(\"Child1Class\")\n</code></pre> <p>The second approach is easier to use, but it forces each class name to be unique. Under the hood, the factory uses the name resolution mechanism to find the path where the class is. If the class name is not unique, the name resolution mechanism will not be able to instantiate the object because of the ambiguity. If several classes have the same name, you need to specify the full name to break the ambiguity.</p> <p>Let's imagine the case where there are two classes with the same name <code>Linear</code>.</p> <pre><code>import torch\n\n# Register the class Linear from PyTorch\nBaseModule.register_object(torch.nn.Linear)\n\n\n# Register another class Linear\nclass Linear(BaseModule):\n    pass\n</code></pre> <p>There is no problem to register to class with the same class name because their full class name are different (<code>torch.nn.modules.linear.Linear</code> vs <code>__main__.Linear</code>). Please read the name resolution mechanism documentation to learn why the real full name of <code>torch.nn.linear.Linear</code> is <code>torch.nn.modules.linear.Linear</code>. If you want to instantiate the <code>Linear</code> class from PyTorch, you will need to give the full class name:</p> <pre><code>my_obj = BaseModule.factory(\"torch.nn.Linear\", in_features=8, out_features=6)\n</code></pre> <p>If you want to instantiate the local <code>Linear</code> class, you will need to give the full class name:</p> <pre><code>my_obj = BaseModule.factory(\"__main__.Linear\", in_features=8, out_features=6)\n</code></pre> <p>If you only specify <code>Linear</code>, the factory does not know what class you want to instantiate and will raise an error.</p> <pre><code>my_obj = BaseModule.factory(\"Linear\", in_features=8, out_features=6)\n# Raise the error: factory.error.UnregisteredObjectFactoryError: Unable to create the object Linear.\n# Registered objects of BaseModule are {'__main__.Linear', 'torch.nn.modules.linear.Linear'}\n</code></pre> <p>If several classes have the same name, the only solution is to specify the full class name. Similarly to class, it is possible to specify the name of the function to call. For example if you want to call the <code>my_nodule</code> function previously defined, you can write:</p> <pre><code>net = BaseModule.factory(\"my_package.nodule.my_nodule\", input_size=4, output_size=12)\n</code></pre> <p>Finally, you can call the <code>factory</code> function with any class that inherits from the base factory class:</p> <pre><code>my_obj = BaseClass.factory(\"my_package.child1.Child1Class\")\n# or\nmy_obj = Child1Class.factory(\"my_package.child1.Child1Class\")\n# or\nmy_obj = Child2Class.factory(\"my_package.child1.Child1Class\")\n</code></pre>"},{"location":"abstract_factory/#initialization-function","title":"Initialization function","text":"<p>By default, the <code>factory</code> function calls the function <code>__init__</code> of a class to create an object. You can also create an object by using a class method. You can use the keyword to <code>_init_</code> to specify the function to use to create the object. The default value of this keyword is <code>\"__init__\"</code> so you do not need to change it if you call the default constructor. Note the initialization function input is only available for the classes. This input is ignored when you call a function to instantiate an object.</p> <p>Let's define a new class that has a class method to create an object:</p> <pre><code># file: my_package/child4.py\nclass Child4Class(BaseClass):\n    def __init__(self, dim: int):\n        self.dim = dim\n\n    @classmethod\n    def default(cls):\n        return cls(dim=256)\n</code></pre> <p>Then, you can create an <code>Child4Class</code> object with the default method with the following command:</p> <pre><code>my_obj = BaseClass.factory(\n    _target_=\"my_package.child4.Child4Class\",\n    _init_=\"default\",\n)\n</code></pre>"},{"location":"abstract_factory/#instantiate-an-unregistered-object","title":"Instantiate an unregistered object","text":"<p>The <code>AbstractFactory</code> metaclass provides some functionalities to dynamically instantiate an unregistered object. This feature is enabled by the name resolution mechanism. It is useful to instantiate an object which is not defined in a third party package. For example if you want to load the class <code>torch.nn.GRU</code>, you can use the following line:</p> <pre><code>net = BaseClass.factory(\"torch.nn.GRU\", input_size=4, hidden_size=12)\n</code></pre> <p>It is not necessary to register this class to instantiate it. If the <code>_target_</code> value is a module path, the <code>factory</code> function tries to import it. If the import is successful, the object is registered in the factory, so it is possible to reuse it later. This functionality is also useful when an object can be initialized by specifying several ways. Due to some imports in the <code>__init__.py</code> of some packages, some objects have several module paths. For example, a GRU object in PyTorch can be created by using the two approaches below:</p> <pre><code>net = BaseClass.factory(\"torch.nn.GRU\", input_size=4, hidden_size=12)\nnet = BaseClass.factory(\"torch.nn.modules.rnn.GRU\", input_size=4, hidden_size=12)\n</code></pre> <p>Please read the name resolution mechanism documentation to learn more about it.</p>"},{"location":"abstract_factory/#tools","title":"Tools","text":"<p>This section presents some useful tools for the <code>AbstractFactory</code> metaclass.</p>"},{"location":"abstract_factory/#register-all-the-child-classes","title":"Register all the child classes","text":"<p>In some cases, you may want to register a class and all its child classes. Instead of doing manually, you can use the function <code>register_child_classes</code>. This function will automatically register the given class and all its child classes. It will find all the child classes and will add them to the registry. It finds the child classes recursively, so it will also find the child classes of the child classes.</p> <p>Let's imagine you have the following classes, and you want to register them to the base class factory <code>BaseClass</code>:</p> <pre><code># file: my_package/my_module.py\nfrom objectory.abstract_factory import register_child_classes\n\n\nclass Foo:\n    pass\n\n\nclass Bar(Foo):\n    pass\n\n\nclass Baz(Foo):\n    pass\n\n\nclass Bing(Bar):\n    pass\n\n\nregister_child_classes(BaseClass, Foo)\nprint(BaseClass.inheritors)\n</code></pre> <p>Output:</p> <pre><code>{\n  'my_package.my_module.Foo',\n  'my_package.my_module.Baz',\n  'my_package.my_module.Bing',\n  'my_package.my_module.Bar'\n}\n</code></pre> <p>By default, the function <code>register_child_classes</code> ignores all the abstract classes because you cannot instantiate them. If you want to also register the abstract classes, you can use the argument <code>ignore_abstract_class=False</code>. The following example shows how to register all the <code>torch.nn.Module</code> including the abstract classes.</p> <pre><code>import torch\nfrom objectory.abstract_factory import register_child_classes\n\nregister_child_classes(BaseClass, torch.nn.Module, ignore_abstract_class=False)\n</code></pre>"},{"location":"abstract_factory/#error-messages","title":"Error messages","text":"<p>This section lists some of the most frequent error messages and explain how to fix the error. If you try to instantiate a class that is not registered (e.g. <code>Child3Class</code>), you will see the following error message:</p> <pre><code>objectory.abstract_factory.UnregisteredClassAbstractFactoryError: Unable to create\nthe class Child3Class. Verify that the class was added to the __init__.py file of its module.\nRegistered child classes of BaseClass are [\"child1class\", \"child2class\"]\n</code></pre> <p>The error shows the list of classes that are registered (<code>[\"my_package.base.BaseClass\", \"my_package.child1.Child1Class\", \"my_package.child2.Child2Class\"]</code> in this example). If your class does not appear in that list, it is probably because your class was never imported and registered. Keep in mind that each class has to be loaded at least once to be registered. The error <code>AbstractClassAbstractFactoryError</code> will be raised if you try to instantiate an abstract class because an abstract class cannot be instantiated.</p>"},{"location":"abstract_factory/#limitations","title":"Limitations","text":"<p>The  <code>AbstractFactory</code> metaclass adds some attributes and methods to the classes. To avoid potential conflicts with the other classes, all the non-public attributes and functions starts with <code>_abstractfactory_****</code> where <code>****</code> is the name of the attribute or the function. As presented above, you cannot define the following methods:</p> <ul> <li><code>inheritors</code></li> <li><code>factory</code></li> <li><code>register_object</code></li> <li><code>unregister</code></li> </ul>"},{"location":"faq/","title":"Frequently Asked Questions (FAQ)","text":""},{"location":"faq/#general-questions","title":"General Questions","text":""},{"location":"faq/#what-is-objectory","title":"What is objectory?","text":"<p>objectory is a Python library that provides general-purpose object factories. It allows you to instantiate objects dynamically without hardcoding class names, making your code more flexible and maintainable. It supports three main approaches: universal factory, abstract factory, and registry patterns.</p>"},{"location":"faq/#when-should-i-use-objectory","title":"When should I use objectory?","text":"<p>objectory is useful when you need to:</p> <ul> <li>Load objects dynamically from configuration files</li> <li>Build plugin systems</li> <li>Create flexible application architectures</li> <li>Avoid tight coupling between classes</li> <li>Support multiple implementations that can be switched at runtime</li> </ul>"},{"location":"faq/#what-are-the-differences-between-the-three-factory-approaches","title":"What are the differences between the three factory approaches?","text":"<ul> <li>Universal Factory (<code>factory()</code>): No registration needed, works with any importable object</li> <li>AbstractFactory: Automatic registration through inheritance, best for related object families</li> <li>Registry: Manual registration with decorators or methods, provides fine-grained control</li> </ul>"},{"location":"faq/#installation","title":"Installation","text":""},{"location":"faq/#what-python-versions-are-supported","title":"What Python versions are supported?","text":"<p>objectory supports Python 3.10 and later. See the get_started page for the compatibility matrix.</p>"},{"location":"faq/#how-do-i-install-objectory","title":"How do I install objectory?","text":"<p>Using <code>uv</code>:</p> <pre><code>uv pip install objectory\n</code></pre> <p>Using <code>pip</code>:</p> <pre><code>pip install objectory\n</code></pre> <p>For more installation options, see the get_started page.</p>"},{"location":"faq/#can-i-use-objectory-without-installing-it","title":"Can I use objectory without installing it?","text":"<p>For development or testing, you can clone the repository and install it in editable mode:</p> <pre><code>git clone https://github.com/durandtibo/objectory.git\ncd objectory\npip install -e .\n</code></pre>"},{"location":"faq/#usage-questions","title":"Usage Questions","text":""},{"location":"faq/#how-do-i-instantiate-an-object-using-the-universal-factory","title":"How do I instantiate an object using the universal factory?","text":"<pre><code>from objectory import factory\n\n# Using full module path with positional arguments\nobj = factory(\"collections.Counter\", [1, 2, 3])\n\n# Using a single positional argument\nobj = factory(\"pathlib.Path\", \"/tmp/example\")\n\n# With keyword arguments\nobj = factory(\"collections.OrderedDict\", a=1, b=2)\n</code></pre>"},{"location":"faq/#can-i-use-custom-class-methods-for-initialization","title":"Can I use custom class methods for initialization?","text":"<p>Yes! Use the <code>_init_</code> parameter:</p> <pre><code>class MyClass:\n    def __init__(self, value):\n        self.value = value\n\n    @classmethod\n    def from_string(cls, s):\n        return cls(int(s))\n\n\n# Using custom initializer\nobj = BaseClass.factory(_target_=\"MyClass\", _init_=\"from_string\", s=\"42\")\n</code></pre>"},{"location":"faq/#how-do-i-resolve-ambiguous-class-names","title":"How do I resolve ambiguous class names?","text":"<p>If multiple classes have the same name, use the full qualified name:</p> <pre><code># Ambiguous - will raise an error if multiple \"Linear\" classes exist\nobj = BaseClass.factory(\"Linear\")\n\n# Unambiguous - specifies exact class\nobj = BaseClass.factory(\"torch.nn.modules.linear.Linear\")\n</code></pre>"},{"location":"faq/#can-i-register-third-party-library-classes","title":"Can I register third-party library classes?","text":"<p>Yes! Use <code>register_object()</code>:</p> <pre><code>import torch\nfrom objectory import AbstractFactory\n\n\nclass BaseModule(torch.nn.Module, metaclass=AbstractFactory):\n    pass\n\n\n# Register PyTorch's Linear\nBaseModule.register_object(torch.nn.Linear)\n\n# Now you can use it\nlinear = BaseModule.factory(\"torch.nn.Linear\", in_features=10, out_features=5)\n</code></pre>"},{"location":"faq/#how-do-i-see-whats-registered-in-a-factory","title":"How do I see what's registered in a factory?","text":"<p>For <code>AbstractFactory</code>:</p> <pre><code>print(BaseClass.inheritors)\n</code></pre> <p>For <code>Registry</code>:</p> <pre><code>print(registry.registered_names())\n</code></pre>"},{"location":"faq/#can-i-use-objectory-with-configuration-files","title":"Can I use objectory with configuration files?","text":"<p>Yes! objectory works great with YAML/JSON configs:</p> <pre><code>import yaml\nfrom objectory import factory\n\n# Load config\nwith open(\"config.yaml\") as f:\n    config = yaml.safe_load(f)\n\n# Instantiate from config\nobj = factory(**config)\n</code></pre>"},{"location":"faq/#advanced-questions","title":"Advanced Questions","text":""},{"location":"faq/#how-does-name-resolution-work","title":"How does name resolution work?","text":"<p>The name resolution mechanism tries to find objects in this order:</p> <ol> <li>Exact match in registered objects</li> <li>Single match by class name only</li> <li>Import and register the object dynamically</li> </ol> <p>See the name resolution documentation for details.</p>"},{"location":"faq/#how-do-i-create-a-plugin-system-with-objectory","title":"How do I create a plugin system with objectory?","text":"<p>You can create a plugin system by using the AbstractFactory metaclass or Registry to register plugin classes dynamically, then instantiate them using the factory pattern based on configuration.</p>"},{"location":"faq/#can-i-register-functions-not-just-classes","title":"Can I register functions, not just classes?","text":"<p>Yes! Both <code>AbstractFactory</code> and <code>Registry</code> support function registration:</p> <pre><code>from objectory import Registry\n\nregistry = Registry()\n\n\n@registry.register()\ndef my_function(x, y):\n    return x + y\n\n\nresult = registry.factory(_target_=\"my_function\", x=1, y=2)\n</code></pre>"},{"location":"faq/#how-do-i-unregister-objects","title":"How do I unregister objects?","text":"<p>For <code>AbstractFactory</code>:</p> <pre><code>BaseClass.unregister(\"MyClass\")\n</code></pre> <p>For <code>Registry</code>:</p> <pre><code>registry.unregister(\"MyClass\")\n</code></pre>"},{"location":"faq/#can-i-clear-all-registered-objects","title":"Can I clear all registered objects?","text":"<p>For <code>Registry</code>:</p> <pre><code># Clear current registry\nregistry.clear()\n\n# Clear including sub-registries\nregistry.clear(nested=True)\n</code></pre> <p>For <code>AbstractFactory</code>, objects are registered permanently and cannot be cleared (this is by design).</p>"},{"location":"faq/#how-do-i-handle-circular-dependencies","title":"How do I handle circular dependencies?","text":"<p>Avoid circular imports by:</p> <ol> <li>Registering objects in <code>__init__.py</code> files</li> <li>Using lazy imports</li> <li>Structuring your code to avoid circular dependencies</li> </ol>"},{"location":"faq/#can-i-use-objectory-with-type-hints","title":"Can I use objectory with type hints?","text":"<p>Yes! For better IDE support:</p> <pre><code>from typing import TypeVar\nfrom objectory import AbstractFactory\n\nT = TypeVar(\"T\", bound=\"BaseClass\")\n\n\nclass BaseClass(metaclass=AbstractFactory):\n    @classmethod\n    def factory(cls, _target_: str, *args, **kwargs) -&gt; \"BaseClass\":\n        return super().factory(_target_, *args, **kwargs)\n</code></pre>"},{"location":"faq/#troubleshooting","title":"Troubleshooting","text":""},{"location":"faq/#i-get-unregisteredobjectfactoryerror","title":"I get \"UnregisteredObjectFactoryError\"","text":"<p>This means the object hasn't been registered. Solutions:</p> <ol> <li>Make sure the module containing the class has been imported</li> <li>Check the class inherits from the base factory class</li> <li>Use <code>register_object()</code> to manually register it</li> <li>Verify the class name spelling</li> </ol>"},{"location":"faq/#my-object-isnt-showing-up-in-inheritors","title":"My object isn't showing up in <code>inheritors</code>","text":"<p>The object must be imported at least once to be registered. Solutions:</p> <ol> <li>Import the module in your <code>__init__.py</code></li> <li>Use the <code>register_child_classes()</code> function</li> <li>Call <code>register_object()</code> explicitly</li> </ol>"},{"location":"faq/#i-get-a-runtimeerror-the-target-object-does-not-exist","title":"I get a \"RuntimeError: The target object does not exist\"","text":"<p>The universal factory cannot find the object. Check:</p> <ol> <li>Is the module path correct?</li> <li>Is the package installed?</li> <li>Can you import it manually with <code>from x import y</code>?</li> </ol>"},{"location":"faq/#performance-concerns-with-large-numbers-of-registered-objects","title":"Performance concerns with large numbers of registered objects","text":"<p>The registry lookup is O(1) for exact matches and O(n) for name resolution. For better performance:</p> <ol> <li>Use full qualified names when possible</li> <li>Avoid having many objects with the same class name</li> <li>Consider using multiple registries to partition objects</li> </ol>"},{"location":"faq/#security","title":"Security","text":""},{"location":"faq/#is-it-safe-to-use-user-input-with-factory-functions","title":"Is it safe to use user input with factory functions?","text":"<p>\u26a0\ufe0f No! Never pass untrusted user input directly to factory functions. The factory can instantiate any Python object, which could be a security risk.</p> <p>Always validate and sanitize input:</p> <pre><code># BAD - Don't do this!\nuser_class = request.get(\"class_name\")\nobj = factory(user_class)\n\n# GOOD - Validate against allowlist\nALLOWED_CLASSES = {\"collections.Counter\", \"collections.defaultdict\"}\nuser_class = request.get(\"class_name\")\nif user_class not in ALLOWED_CLASSES:\n    raise ValueError(\"Class not allowed\")\nobj = factory(user_class)\n</code></pre> <p>See SECURITY.md for more security guidelines.</p>"},{"location":"faq/#contributing","title":"Contributing","text":""},{"location":"faq/#how-can-i-contribute-to-objectory","title":"How can I contribute to objectory?","text":"<p>We welcome contributions! See CONTRIBUTING.md for guidelines.</p>"},{"location":"faq/#i-found-a-bug-what-should-i-do","title":"I found a bug, what should I do?","text":"<p>Please open an issue on GitHub with:</p> <ul> <li>A clear description of the bug</li> <li>Steps to reproduce</li> <li>Expected vs actual behavior</li> <li>Your Python version and objectory version</li> </ul>"},{"location":"faq/#can-i-request-a-feature","title":"Can I request a feature?","text":"<p>Yes! Open a feature request issue on GitHub. Please describe:</p> <ul> <li>The use case</li> <li>Why existing features don't work</li> <li>Proposed API (if applicable)</li> </ul>"},{"location":"faq/#getting-help","title":"Getting Help","text":""},{"location":"faq/#where-can-i-ask-questions","title":"Where can I ask questions?","text":"<ul> <li>Open a discussion on GitHub</li> <li>Open an issue for bugs or feature requests</li> <li>Check existing documentation and examples</li> </ul>"},{"location":"faq/#are-there-more-examples","title":"Are there more examples?","text":"<p>Check the documentation for code examples throughout the user guide pages (abstract factory, registry, universal factory, etc.).</p>"},{"location":"get_started/","title":"Get Started","text":"<p>It is highly recommended to install in a virtual environment to keep your system in order.</p>"},{"location":"get_started/#installing-with-uv-recommended","title":"Installing with <code>uv</code> (recommended)","text":"<p>The following command installs the latest stable version of the library:</p> <pre><code>uv pip install objectory\n</code></pre> <p>To install the latest development version from GitHub:</p> <pre><code>uv pip install git+https://github.com/durandtibo/objectory.git\n</code></pre> <p>To install a specific version:</p> <pre><code>uv pip install objectory==0.2.2\n</code></pre>"},{"location":"get_started/#installing-with-pip","title":"Installing with <code>pip</code>","text":"<p>The following command installs the latest stable version of the library:</p> <pre><code>pip install objectory\n</code></pre> <p>To install the latest development version from GitHub:</p> <pre><code>pip install git+https://github.com/durandtibo/objectory.git\n</code></pre> <p>To install a specific version:</p> <pre><code>pip install objectory==0.2.2\n</code></pre>"},{"location":"get_started/#verifying-installation","title":"Verifying Installation","text":"<p>After installation, you can verify that objectory is correctly installed by running:</p> <pre><code>python -c \"import objectory; print(objectory.__version__)\"\n</code></pre> <p>Or try a simple example:</p> <pre><code>from objectory import factory\n\n# Create a Counter object from the standard library\ncounter = factory(\"collections.Counter\", [1, 2, 1, 3])\nprint(counter)  # Output: Counter({1: 2, 2: 1, 3: 1})\n</code></pre>"},{"location":"get_started/#installing-from-source","title":"Installing from source","text":"<p>To install <code>objectory</code> from source, you can follow the steps below.</p>"},{"location":"get_started/#prerequisites","title":"Prerequisites","text":"<p>This project uses <code>uv</code> for dependency management. Please refer to the uv installation documentation for installation instructions.</p>"},{"location":"get_started/#clone-the-repository","title":"Clone the Repository","text":"<pre><code>git clone git@github.com:durandtibo/objectory.git\ncd objectory\n</code></pre>"},{"location":"get_started/#create-a-virtual-environment","title":"Create a Virtual Environment","text":"<p>It is recommended to create a Python 3.10+ virtual environment:</p> <pre><code>make setup-venv\n</code></pre> <p>This command creates a virtual environment using <code>uv</code> and installs all dependencies including development tools.</p> <p>Alternatively, you can create a conda virtual environment:</p> <pre><code>make conda\nconda activate objectory\nmake install\n</code></pre>"},{"location":"get_started/#install-dependencies","title":"Install Dependencies","text":"<p>To install only the core dependencies:</p> <pre><code>make install\n</code></pre> <p>To install all dependencies including documentation tools:</p> <pre><code>make install-all\n</code></pre>"},{"location":"get_started/#verify-installation","title":"Verify Installation","text":"<p>You can test the installation with the following command:</p> <pre><code>make unit-test-cov\n</code></pre> <p>This will run the test suite with coverage reporting.</p>"},{"location":"get_started/#development-setup","title":"Development Setup","text":"<p>If you plan to contribute to objectory, please also install the development tools.</p> <p>Using <code>uv</code>:</p> <pre><code>uv pip install -e \".[dev,docs]\"\n</code></pre> <p>Using <code>pip</code>:</p> <pre><code>pip install -e \".[dev,docs]\"\n</code></pre> <p>Then install the pre-commit hooks:</p> <pre><code>pre-commit install\n</code></pre> <p>See CONTRIBUTING.md for more information about contributing.</p>"},{"location":"github_workflows/","title":"GitHub Actions Workflows","text":"<p>This document provides an overview of the GitHub Actions workflows and the structure of the <code>.github</code> folder in the <code>objectory</code> repository.</p>"},{"location":"github_workflows/#overview","title":"Overview","text":"<p>The repository uses GitHub Actions for continuous integration, testing, documentation deployment, and package publishing. The workflows are designed to be modular and reusable, with a custom composite action for setting up the development environment.</p>"},{"location":"github_workflows/#github-folder-structure","title":"<code>.github</code> Folder Structure","text":"<pre><code>.github/\n\u251c\u2500\u2500 actions/                    # Custom composite actions\n\u2502   \u2514\u2500\u2500 setup-env/             # Reusable action for environment setup\n\u2502       \u2514\u2500\u2500 action.yaml\n\u251c\u2500\u2500 workflows/                  # GitHub Actions workflow definitions\n\u2502   \u251c\u2500\u2500 build.yaml             # Build and package tests\n\u2502   \u251c\u2500\u2500 ci.yaml                # Main CI workflow\n\u2502   \u251c\u2500\u2500 coverage.yaml          # Code coverage reporting\n\u2502   \u251c\u2500\u2500 test.yaml              # Unit and integration tests\n\u2502   \u251c\u2500\u2500 docs.yaml              # Documentation deployment\n\u2502   \u251c\u2500\u2500 pypi.yaml              # PyPI package publishing\n\u2502   \u2514\u2500\u2500 ...                    # Additional workflows\n\u251c\u2500\u2500 CONTRIBUTING.md            # Contribution guidelines\n\u251c\u2500\u2500 ISSUE_TEMPLATE/            # Issue templates\n\u2502   \u251c\u2500\u2500 bug-report.yml\n\u2502   \u2514\u2500\u2500 feature-request.yml\n\u251c\u2500\u2500 PULL_REQUEST_TEMPLATE.md   # Pull request template\n\u2514\u2500\u2500 dependabot.yml             # Dependabot configuration\n</code></pre>"},{"location":"github_workflows/#custom-composite-action","title":"Custom Composite Action","text":""},{"location":"github_workflows/#setup-env","title":"<code>setup-env</code>","text":"<p>Location: <code>.github/actions/setup-env/action.yaml</code></p> <p>A reusable composite action that handles the common setup steps for most workflows.</p> <p>Purpose:</p> <ul> <li>Installs <code>uv</code> package manager</li> <li>Sets up Python environment</li> <li>Installs dependencies using invoke tasks</li> <li>Shows environment configuration and dependency tree</li> </ul> <p>Inputs:</p> <ul> <li><code>python-version</code>: Python version to use (default: <code>3.13</code>)</li> <li><code>package-name</code>: Optional package name to install</li> <li><code>package-version</code>: Optional package version to install</li> <li><code>install-args</code>: Optional arguments when installing dependencies (e.g., <code>--docs-deps</code>,   <code>--no-optional-deps</code>)</li> </ul> <p>Usage:</p> <pre><code>- name: Setup python environment\n  uses: ./.github/actions/setup-env\n  with:\n    python-version: '3.12'\n    install-args: '--docs-deps'\n</code></pre>"},{"location":"github_workflows/#main-workflows","title":"Main Workflows","text":""},{"location":"github_workflows/#ci-workflow-ciyaml","title":"CI Workflow (<code>ci.yaml</code>)","text":"<p>Triggers:</p> <ul> <li>Pull requests to <code>main</code> branch</li> <li>Pushes to <code>main</code> branch</li> <li>Manual workflow dispatch</li> </ul> <p>Purpose: Main continuous integration workflow that orchestrates all quality checks.</p> <p>Jobs: Calls the following reusable workflows:</p> <ul> <li><code>build</code> - Package build tests</li> <li><code>coverage</code> - Code coverage reporting</li> <li><code>cyclic-imports</code> - Cyclic import detection</li> <li><code>doctest</code> - Documentation tests</li> <li><code>format</code> - Code formatting checks</li> <li><code>pre-commit</code> - Pre-commit hook validation</li> <li><code>test</code> - Unit and integration tests</li> <li><code>test-deps</code> - Dependency compatibility tests</li> </ul>"},{"location":"github_workflows/#build-tests-buildyaml","title":"Build Tests (<code>build.yaml</code>)","text":"<p>Triggers:</p> <ul> <li>Called by other workflows (<code>workflow_call</code>)</li> <li>Manual workflow dispatch</li> </ul> <p>Purpose: Validates that the package can be built and installed correctly.</p> <p>Jobs:</p> <ol> <li> <p>build:</p> <ul> <li>Builds the package using <code>uv build</code></li> <li>Installs the wheel package</li> <li>Verifies basic import works</li> <li>Shows dependency tree</li> </ul> </li> <li> <p>extras:</p> <ul> <li>Tests installation with optional dependencies</li> <li>Matrix strategy for different extras (e.g., <code>all</code>)</li> </ul> </li> </ol>"},{"location":"github_workflows/#test-workflow-testyaml","title":"Test Workflow (<code>test.yaml</code>)","text":"<p>Triggers:</p> <ul> <li>Called by other workflows (<code>workflow_call</code>)</li> <li>Manual workflow dispatch</li> </ul> <p>Purpose: Runs comprehensive test suite across multiple Python versions and operating systems.</p> <p>Jobs:</p> <ol> <li> <p>all:</p> <ul> <li>Runs on multiple OS: Ubuntu (latest, 24.04, 22.04, ARM), macOS (latest, 26, 15, 14, Intel)</li> <li>Tests Python versions: 3.10, 3.11, 3.12, 3.13, 3.14 (including free-threaded builds)</li> <li>Runs unit and integration tests with coverage</li> </ul> </li> <li> <p>min:</p> <ul> <li>Same matrix as <code>all</code> but with minimal dependencies (<code>--no-optional-deps</code>)</li> <li>Ensures the package works without optional dependencies</li> </ul> </li> </ol>"},{"location":"github_workflows/#coverage-workflow-coverageyaml","title":"Coverage Workflow (<code>coverage.yaml</code>)","text":"<p>Triggers:</p> <ul> <li>Called by other workflows (<code>workflow_call</code>)</li> <li>Manual workflow dispatch</li> </ul> <p>Purpose: Generates code coverage reports and uploads them to Codecov.</p> <p>Jobs:</p> <ul> <li>Runs unit and integration tests with coverage</li> <li>Uploads coverage data to Codecov (only for the main repository)</li> <li>Failures in uploading to Codecov do not fail the workflow</li> </ul>"},{"location":"github_workflows/#documentation-workflows","title":"Documentation Workflows","text":""},{"location":"github_workflows/#stable-documentation-docsyaml","title":"Stable Documentation (<code>docs.yaml</code>)","text":"<p>Triggers:</p> <ul> <li>Version tags (<code>v*.*.*</code>)</li> <li>Manual workflow dispatch</li> </ul> <p>Purpose: Builds and deploys documentation for stable releases.</p> <p>Jobs:</p> <ul> <li>Sets up environment with documentation dependencies</li> <li>Configures git for the docs bot</li> <li>Publishes documentation using <code>mike</code> (documentation versioning tool)</li> </ul>"},{"location":"github_workflows/#development-documentation-docs-devyaml","title":"Development Documentation (<code>docs-dev.yaml</code>)","text":"<p>Triggers:</p> <ul> <li>Pushes to <code>main</code> branch</li> <li>Manual workflow dispatch</li> </ul> <p>Purpose: Builds and deploys documentation for the development version.</p>"},{"location":"github_workflows/#pypi-publishing-pypiyaml","title":"PyPI Publishing (<code>pypi.yaml</code>)","text":"<p>Triggers:</p> <ul> <li>Version tags (<code>v*.*.*</code>)</li> <li>Manual workflow dispatch</li> </ul> <p>Purpose: Publishes the package to PyPI.</p> <p>Jobs:</p> <ul> <li>Installs <code>uv</code> and <code>invoke</code></li> <li>Runs the publish command with PyPI token from secrets</li> </ul>"},{"location":"github_workflows/#additional-workflows","title":"Additional Workflows","text":""},{"location":"github_workflows/#nightly-tests-nightly-testsyaml","title":"Nightly Tests (<code>nightly-tests.yaml</code>)","text":"<p>Triggers:</p> <ul> <li>Scheduled daily at 9:10 AM UTC</li> <li>Manual workflow dispatch</li> </ul> <p>Purpose: Runs the full test suite nightly to catch issues early.</p>"},{"location":"github_workflows/#nightly-package-tests-nightly-packageyaml","title":"Nightly Package Tests (<code>nightly-package.yaml</code>)","text":"<p>Triggers:</p> <ul> <li>Scheduled daily at 10:30 AM UTC</li> <li>Manual workflow dispatch</li> </ul> <p>Purpose: Tests package installation and imports nightly.</p>"},{"location":"github_workflows/#pre-commit-pre-commityaml","title":"Pre-commit (<code>pre-commit.yaml</code>)","text":"<p>Triggers:</p> <ul> <li>Called by other workflows</li> <li>Manual workflow dispatch</li> </ul> <p>Purpose: Runs pre-commit hooks to validate code style and quality.</p>"},{"location":"github_workflows/#pre-commit-auto-update-pre-commit-autoupdateyaml","title":"Pre-commit Auto-update (<code>pre-commit-autoupdate.yaml</code>)","text":"<p>Triggers:</p> <ul> <li>Scheduled weekly on Sundays at 5:10 AM UTC</li> <li>Manual workflow dispatch</li> </ul> <p>Purpose: Automatically updates pre-commit hook versions.</p>"},{"location":"github_workflows/#format-check-formatyaml","title":"Format Check (<code>format.yaml</code>)","text":"<p>Triggers:</p> <ul> <li>Called by other workflows</li> <li>Manual workflow dispatch</li> </ul> <p>Purpose: Checks code formatting using Black and Ruff.</p>"},{"location":"github_workflows/#cyclic-imports-cyclic-importsyaml","title":"Cyclic Imports (<code>cyclic-imports.yaml</code>)","text":"<p>Triggers:</p> <ul> <li>Called by other workflows</li> <li>Manual workflow dispatch</li> </ul> <p>Purpose: Detects circular import dependencies.</p>"},{"location":"github_workflows/#doctest-doctestyaml","title":"Doctest (<code>doctest.yaml</code>)","text":"<p>Triggers:</p> <ul> <li>Called by other workflows</li> <li>Manual workflow dispatch</li> </ul> <p>Purpose: Runs doctests to validate code examples in documentation.</p>"},{"location":"github_workflows/#test-dependencies-test-depsyaml","title":"Test Dependencies (<code>test-deps.yaml</code>)","text":"<p>Triggers:</p> <ul> <li>Called by other workflows</li> <li>Manual workflow dispatch</li> </ul> <p>Purpose: Tests the package with different versions of dependencies.</p>"},{"location":"github_workflows/#dependency-review-dependency-reviewyml","title":"Dependency Review (<code>dependency-review.yml</code>)","text":"<p>Triggers:</p> <ul> <li>Pull requests</li> </ul> <p>Purpose: Reviews dependency changes for security vulnerabilities.</p>"},{"location":"github_workflows/#update-dependencies-update-depsyaml","title":"Update Dependencies (<code>update-deps.yaml</code>)","text":"<p>Triggers:</p> <ul> <li>Scheduled weekly on Sundays at 5:10 AM UTC</li> <li>Manual workflow dispatch</li> </ul> <p>Purpose: Creates pull requests to update dependencies.</p>"},{"location":"github_workflows/#cancel-stale-queued-runs-cancel_stale_queued_runsyaml","title":"Cancel Stale Queued Runs (<code>cancel_stale_queued_runs.yaml</code>)","text":"<p>Triggers:</p> <ul> <li>Push to any branch</li> <li>Pull requests</li> </ul> <p>Purpose: Cancels outdated workflow runs to save CI resources.</p>"},{"location":"github_workflows/#generate-package-versions-generate-package-versionsyaml","title":"Generate Package Versions (<code>generate-package-versions.yaml</code>)","text":"<p>Triggers:</p> <ul> <li>Manual workflow dispatch</li> </ul> <p>Purpose: Generates version compatibility documentation.</p>"},{"location":"github_workflows/#get-versions-get-versionsyaml","title":"Get Versions (<code>get-versions.yaml</code>)","text":"<p>Triggers:</p> <ul> <li>Manual workflow dispatch</li> </ul> <p>Purpose: Retrieves version information from the project.</p>"},{"location":"github_workflows/#workflow-permissions","title":"Workflow Permissions","text":"<p>Most workflows use minimal permissions following the principle of least privilege:</p> <ul> <li><code>contents: read</code> - Default for read-only operations</li> <li><code>contents: write</code> - Only for workflows that need to push changes (e.g., documentation deployment)</li> </ul>"},{"location":"github_workflows/#secrets-used","title":"Secrets Used","text":"<p>The following secrets are configured in the repository settings:</p> <ul> <li><code>CODECOV_TOKEN</code> - For uploading coverage reports to Codecov</li> <li><code>PYPI_TOKEN</code> - For publishing packages to PyPI</li> <li><code>CI_BOT_EMAIL</code> - Email address for the CI bot (used for documentation deployment)</li> </ul>"},{"location":"github_workflows/#best-practices","title":"Best Practices","text":"<ol> <li> <p>Reusable Workflows: Common workflows are defined with <code>workflow_call</code> trigger so they can be    reused by other workflows.</p> </li> <li> <p>Matrix Testing: The test workflows use matrix strategies to test across multiple Python    versions and operating systems.</p> </li> <li> <p>Composite Actions: The <code>setup-env</code> action centralizes common setup steps, reducing    duplication.</p> </li> <li> <p>Timeouts: All jobs have reasonable timeout limits (typically 10 minutes) to prevent hung    workflows.</p> </li> <li> <p>Fail-Fast: Most matrix jobs use <code>fail-fast: false</code> to continue testing other combinations    even if one fails.</p> </li> <li> <p>Version Pinning: GitHub Actions are pinned to specific major versions (e.g., <code>@v6</code>, <code>@v7</code>)    for stability.</p> </li> <li> <p>Minimal Changes: Workflows are designed to make minimal assumptions about the environment and    clean up after themselves.</p> </li> </ol>"},{"location":"github_workflows/#dependabot-configuration","title":"Dependabot Configuration","text":"<p>The repository uses Dependabot to automatically update GitHub Actions dependencies. The configuration is in <code>.github/dependabot.yml</code>.</p>"},{"location":"github_workflows/#issue-and-pull-request-templates","title":"Issue and Pull Request Templates","text":"<p>The repository provides templates to help contributors submit well-structured issues and pull requests:</p> <ul> <li>Bug Report: <code>.github/ISSUE_TEMPLATE/bug-report.yml</code></li> <li>Feature Request: <code>.github/ISSUE_TEMPLATE/feature-request.yml</code></li> <li>Pull Request Template: <code>.github/PULL_REQUEST_TEMPLATE.md</code></li> </ul>"},{"location":"github_workflows/#contributing","title":"Contributing","text":"<p>For detailed information about contributing to the project, including how to run tests locally and development setup, see CONTRIBUTING.md.</p>"},{"location":"name_resolution/","title":"Name Resolution Mechanism","text":"<p> Before to read this page, it is recommended to know how an object factory works. This page introduces the name resolution mechanism (NRM) which is used to find the real full name of the object that you want to load dynamically.</p>"},{"location":"name_resolution/#motivation","title":"Motivation","text":"<p>This section explains why the name resolution mechanism is important. To instantiate dynamically an object with an object factory, you need to specify the name of the object. Then, the object factory will look at its internal registry to find where is the object associated to the name that you gave. A problem happens when there are several ways to instantiate an object.</p> <p>Let's take the example of PyTorch \u2013note that the motivation is not specific to PyTorch and you can find similar situations in other libraries. PyTorch is an open source machine learning framework that accelerates the path from research prototyping to production deployment. In particular, let's look at the <code>torch.nn.Linear</code> class. According to the documentation, you can use this class in your code by writing something like:</p> <pre><code>from torch.nn import Linear\n</code></pre> <p>It will work but if you print the class <code>Linear</code>, you will see that the real path to it is not <code>torch.nn.Linear</code>. The real path of the class <code>Linear</code> class is:</p> <pre><code>torch.nn.modules.linear.Linear\n</code></pre> <p>Another way to import the class <code>Linear</code> is to write:</p> <pre><code>from torch.nn.modules.linear import Linear\n</code></pre> <p>So there are at least two ways to import the class <code>Linear</code>:</p> <ul> <li><code>from torch.nn import Linear</code></li> <li><code>from torch.nn.modules.linear import Linear</code></li> </ul> <p>Both approaches will give the same result. Which one should you use? </p> <p>Choosing one approach is probably not a good idea because it will force all the users to use the same approach which can be challenging in practice. A solution is to use a name resolution mechanism which will allow using several approaches to instantiate an object. By default, the <code>objectory</code> library uses the real full name to register an object. Each object is registered with its real full name, so in the PyTorch example, the class <code>Linear</code> is registered with the name <code>torch.nn.modules.linear.Linear</code>.</p> <p>The factory should understand that you can use <code>torch.nn.modules.linear.Linear</code> or <code>torch.nn.Linear</code> to instantiate the class <code>Linear</code>. If you give <code>torch.nn.Linear</code>, the name resolution mechanism should transform it in <code>torch.nn.modules.linear.Linear</code>.</p> <p>For the PyTorch library, the development team recommend to use <code>torch.nn.Linear</code> instead of <code>torch.nn.modules.linear.Linear</code> because it will make your code more robust to some changes in the package <code>torch.nn</code>. The name resolution mechanism will allow you to do that because you do not have to give the real full name of the object. Internally, the factory uses <code>torch.nn.modules.linear.Linear</code> and it connects the name <code>torch.nn.Linear</code> to <code>torch.nn.modules.linear.Linear</code> so specifying <code>torch.nn.Linear</code> is equivalent to write <code>torch.nn.modules.linear.Linear</code>.</p> <p>Another advantage of the name resolution mechanism is that you can specify only the object (class or function) name. Writing the full name of each object can be time-consuming. The advantage of writing the full name is that there is no ambiguity of the object that you want to instantiate if there are several objects with the same name. However, it is possible to use the information about the registered objects in the factory to find the object to use. For example if you want to instantiate an object of class <code>X</code>, you can look at how many objects with name <code>X</code> are registered in the factory. The name resolution mechanism will work if there is a single match i.e. there is a single registered object with the name <code>X</code>. It will not work if there are several matches because the factory does not know which object to choose. In that case you will have to use the full name of the object to break the ambiguity.</p> <p>If we continue with the previous example, you can use the query <code>Linear</code> to instantiate the class if there is no other object with that name in the factory. The name resolution mechanism will explore the names registered in the factory and will find it matches with <code>torch.nn.modules.linear.Linear</code>. It will associate <code>Linear</code> to <code>torch.nn.modules.linear.Linear</code>.</p>"},{"location":"name_resolution/#how-to-use-name-resolution-mechanism","title":"How to use name resolution mechanism","text":"<p>It is quite easy to use the name resolution mechanism, and it can be used outside the object factories. The first input is the query name, and the second input is the set of possible object names. In the object factory implementations, it is the set of registered object names. For the following example, let's assume the set of possible object names is: <code>{'torch.nn.modules.linear.Linear', 'my_package.MyClass'}</code>. The name resolution mechanism will try to find the query name in the set of possible object names. Let's assume that the query name is <code>'Linear'</code>. To use the name resolution mechanism, you can write the following code:</p> <pre><code>from objectory.utils import resolve_name\n\nprint(resolve_name(\"Linear\", {\"torch.nn.modules.linear.Linear\", \"my_package.MyClass\"}))\n</code></pre> <p>Output:</p> <pre><code>torch.nn.modules.linear.Linear\n</code></pre> <p>In this example, the resolved name is <code>'torch.nn.modules.linear.Linear'</code> because there is a single object with the name <code>Linear</code> in the set. Please read the next section to learn how the name resolution is done. The name resolution mechanism returns <code>None</code> if it cannot find the name.</p>"},{"location":"name_resolution/#how-does-the-name-resolution-mechanism-work","title":"How does the name resolution mechanism work?","text":"<p>The name resolution mechanism works in several steps. The inputs are a query name, and a set of object names. Then, the name resolution mechanism will try to find the full name of the object by using the following sequential process:</p> <ul> <li>Step 1. The first step looks at if the query name is in the set of object names.   If yes, it returns the query name because it can be directly used to instantiate the object.   If no, it goes to the second step.</li> <li>Step 2. The second step looks at the potential matches to the query name.   If there is a single match, it returns the matched object name because it can be directly used to   instantiate the object.   If there are multiple matches, it goes to the third step.   This step is useful to manage the case where the user only specifies the object name.   For example, it will work if the query name is <code>Linear</code> and the set of possible object names   is: <code>{'torch.nn.modules.linear.Linear', 'my_package.MyClass'}</code>.</li> <li>Step 3. The last step tries to import the object.   If the object can be imported, it returns the full name of the object.   If the object cannot be imported, it returns <code>None</code>.   This step is useful to manage the case where there are multiple ways to import an object.   For example if the query name is <code>torch.nn.Linear</code>, it will find that the real full   name is <code>torch.nn.modules.linear.Linear</code>.</li> </ul>"},{"location":"name_resolution/#matching-mechanism","title":"Matching mechanism","text":"<p>This section explains the matching mechanism used in the step 2 of the name resolution mechanism. Similarly to the name resolution mechanism, the inputs of the matching mechanism are a query name, and a set of object names. The matching mechanism returns a set of matches. First, the matching mechanism looks at if the query name is a valid python identifier. You can read this page to learn more about the Python identifier. If the query name is not a valid python identifier, the matching mechanism returns an empty set. If the query name is a valid python identifier, it finds the matches between the query name, and the python identifier of each object name in the set of object names. It returns the set of matches.</p>"},{"location":"name_resolution/#ignore-new-import","title":"Ignore new import","text":"<p>It is possible to ignore the new imports in the third step by setting <code>allow_import=False</code>. In some cases, we do not want to use an object which is not in the set of object names. By default, the name resolution mechanism returns the full name of the object if the import was successful in the third step. If <code>allow_import=False</code>, the name resolution mechanism tries to import the object and check if the name is in the set of object names. If we use the example presented above on <code>torch.nn.Linear</code>, we can write something:</p> <pre><code>from objectory.utils import resolve_name\n\nprint(\n    resolve_name(\n        \"torch.nn.Linear\", {\"torch.nn.modules.linear.Linear\"}, allow_import=False\n    )\n)\n</code></pre> <p>Output:</p> <pre><code>torch.nn.modules.linear.Linear\n</code></pre> <p>The name resolution mechanism finds that the full name of <code>torch.nn.Linear</code> is <code>torch.nn.modules.linear.Linear</code>. If <code>torch.nn.modules.linear.Linear</code> is not in the set of object names, the name resolution mechanism does not find the full name and returns <code>None</code>:</p> <pre><code>from objectory.utils import resolve_name\n\nprint(resolve_name(\"torch.nn.Linear\", {\"something.my_linear\"}, allow_import=False))\n</code></pre> <p>Output:</p> <pre><code>None\n</code></pre>"},{"location":"registry/","title":"Registry","text":"<p>The <code>Registry</code> can be used to register a class or a function.</p>"},{"location":"registry/#register-an-object","title":"Register an object","text":"<p>This section explains the basics on how to register an object (class or function). There are two approaches to register an object to the registry:</p> <ul> <li>by using the decorator <code>register</code></li> <li>by using the function <code>register_object</code></li> </ul>"},{"location":"registry/#decorator-register","title":"Decorator <code>register</code>","text":"<p>You can use the decorator <code>register</code> to register an object to the registry. For example if you want to register the class <code>ClassToRegister</code>, you can write:</p> <pre><code># file: my_package/my_module.py\nfrom objectory import Registry\n\nregistry = Registry()\n\n\n@registry.register()\nclass ClassToRegister:\n    pass\n\n\nprint(registry.registered_names())\n</code></pre> <p>Output:</p> <pre><code>{'my_package.my_module.ClassToRegister'}\n</code></pre> <p>The class <code>ClassToRegister</code> is registered with the name <code>my_package.my_module.ClassToRegister</code>. You can see the registered names by using the function <code>registered_names</code>. The function <code>registered_names</code> returns the set of registered names.</p> <p>You can also use the decorator <code>register</code> to register a function:</p> <pre><code># file: my_package/my_module.py\nfrom objectory import Registry\n\nregistry = Registry()\n\n\n@registry.register()\ndef function_to_register(*args, **kwargs):\n    pass\n\n\nprint(registry.registered_names())\n</code></pre> <p>Output:</p> <pre><code>{'my_package.my_module.function_to_register'}\n</code></pre> <p>The function <code>function_to_register</code> is registered with the name <code>my_package.my_module.function_to_register</code>.</p>"},{"location":"registry/#function-register_object","title":"Function <code>register_object</code>","text":"<p>The decorator approach works well when you can change the source code, but it will not work if you cannot modify the source code. You cannot use the decorator <code>register</code> to register an object in a third party library. To register a class or function from a third party library, you can use the function <code>register_object</code>. For example if you want to register the class <code>ClassToRegister</code> of the library <code>third_party</code>, you can write the following lines:</p> <pre><code># file: my_package/my_module.py\nfrom objectory import Registry\nfrom third_party import ClassToRegister\n\nregistry = Registry()\n\nregistry.register_object(ClassToRegister)\n</code></pre> <p>Similarly to the decorator <code>register</code>, you can use the function <code>register_object</code> to register a function:</p> <pre><code># file: my_package/my_module.py\nfrom objectory import Registry\nfrom third_party import function_to_register\n\nregistry = Registry()\n\nregistry.register_object(function_to_register)\n</code></pre> <p> It is not possible to register a lambda function. Please use a regular python function instead. The registry will raise the exception <code>IncorrectObjectFactoryError</code> if you try to register a lambda function.</p>"},{"location":"registry/#advanced-object-registration","title":"Advanced object registration","text":"<p>This section presents some advanced features to register an object.</p>"},{"location":"registry/#sub-registry","title":"Sub-registry","text":"<p>Previously we showed how to register an object to the registry, but all the objects will be registered to the same registry which can be messy in some cases. Instead, you can decide to use a hierarchical structure and to use sub-registries. The registry will have a tree structure. <code>registry</code> is the main registry, and you can add some sub-registries. Each sub-registry works like the main registry. In fact, the main registry and the sub-registries are implemented with the same class (<code>Registry</code>). It is not a hard coded rule, but it is recommended to use one sub-registry for each \"family\" of objects to group the similar objects.</p> <p>If you want to register the class in the sub-registry <code>other</code>, you can write:</p> <pre><code># file: my_package/my_module.py\nfrom objectory import Registry\n\nregistry = Registry()\n\n\n@registry.other.register()\nclass ClassToRegister:\n    pass\n\n\nprint(registry.registered_names())\nprint(registry.other.registered_names())\n</code></pre> <p>Output:</p> <pre><code>{'other'}\n{'my_package.my_module.ClassToRegister'}\n</code></pre> <p>You can check the registered objects in <code>registry</code> and <code>registry.other</code>. The class <code>ClassToRegister</code> is registered into <code>registry.other</code> and not <code>registry</code>. Note that the sub-registry <code>other</code> is registered to the main registry with the name <code>other</code>. It means you cannot use the name <code>other</code> to register an object. Each sub-registry is considered as a registered object in the parent registry. The sub-registry <code>other</code> will be created if it does not exist, so you do not have to manually register the new sub-registry. It is possible to have a nested structure where you add a sub-registry to a sub-registry:</p> <pre><code>from objectory import Registry\n\nregistry = Registry()\n\n\n@registry.animal.cat.register()\nclass MyCat:\n    pass\n\n\n@registry.animal.bear.register()\nclass MyBear:\n    pass\n</code></pre>"},{"location":"registry/#register-all-the-child-classes","title":"Register all the child classes","text":"<p>In some cases, you may want to register a class and all its child classes. Instead of doing manually, you can use the function <code>register_child_classes</code>. This function will automatically register the given class and all its child classes. It will find all the child classes and will add them to the registry. It finds the child classes recursively, so it will also find the child classes of the child classes.</p> <p>Let's imagine you have the following classes and you want to register them.</p> <pre><code># file: my_package/my_module.py\nfrom objectory import Registry\n\n\nclass Foo:\n    pass\n\n\nclass Bar(Foo):\n    pass\n\n\nclass Baz(Foo):\n    pass\n\n\nclass Bing(Bar):\n    pass\n\n\nregistry = Registry()\n\n# If you want to register Foo and all its child classes.\nregistry.register_child_classes(Foo)\nprint(registry.registered_names())\n\n# If you want to register Bar and all its child classes.\nregistry.bar.register_child_classes(Bar)\nprint(registry.bar.registered_names())\n</code></pre> <p>Output:</p> <pre><code>{'my_package.my_module.Foo', 'my_package.my_module.Baz',\n 'my_package.my_module.Bing', 'my_package.my_module.Bar'}\n{'my_package.my_module.Bing', 'my_package.my_module.Bar'}\n</code></pre> <p>By default, the function <code>register_child_classes</code> ignores all the abstract classes because you cannot instantiate them. If you want to also register the abstract classes, you can use the argument <code>ignore_abstract_class=False</code>. The following example shows how to register all the <code>torch.nn.Module</code> including the abstract classes.</p> <pre><code>import torch\nfrom objectory import Registry\n\nregistry = Registry()\nregistry.register_child_classes(torch.nn.Module, ignore_abstract_class=False)\n</code></pre>"},{"location":"registry/#customized-name","title":"Customized name","text":"<p>By default, the registry uses the full name of the object to identify the object in the registry. It is possible to customize the name used to register an object. For example if you want to register the class <code>ClassToRegister</code> with the name <code>my_class</code>, you can write the following code:</p> <pre><code># file: my_package/my_module.py\nfrom objectory import Registry\n\nregistry = Registry()\n\n\n@registry.register(\"my_class\")\nclass ClassToRegister:\n    pass\n\n\nregistry.register_object(ClassToRegister, \"my_class\")\n# or\nregistry.register_object(ClassToRegister, name=\"my_class\")\n</code></pre> <p>One of the advantage of using customizable names is that you can define shorter name: <code>my_class</code> is shorter than <code>my_package.my_module.ClassToRegister</code>. But using customizable names is not a free lunch, and it has a cost: it will be your responsibility to manage the names to avoid the conflicts. If two objects are registered with the same name, only the last object will be registered. For this reason, it is recommended to use the full name (default) because the full name is unique.</p> <p>Please think carefully about the pros and cons of this feature before to use it. In most of the cases you probably do not need it. Keep in mind that with power comes responsibility.</p>"},{"location":"registry/#factory","title":"Factory","text":"<p>The reserved keywords are:</p> <ul> <li><code>_target_</code>: the class/function to instantiate</li> <li><code>_init_</code>: the constructor to use to instantiate a class</li> </ul>"},{"location":"registry/#remove-objects","title":"Remove objects","text":"<p>In the previous sections, we explain how to add objects to the registry. In this section, we will explain how to remove them.</p>"},{"location":"registry/#remove-all-the-objects","title":"Remove all the objects","text":"<p>If you want to remove all the objects in a registry, you can use the function <code>clear</code>:</p> <pre><code>from objectory import Registry\n\nregistry = Registry()\n\n\nclass ClassToRegister:\n    pass\n\n\nregistry.register_object(ClassToRegister)\nprint(registry.registered_names())\n\nregistry.clear()\nprint(registry.registered_names())\n</code></pre> <p>Output:</p> <pre><code>set()\n</code></pre> <p>This function remove all the registered objects including the sub-registries. For example, if the registry has a sub-registry <code>other</code>, this line of code will also clear the sub-registry <code>other</code>. You can use this function on a sub-registry to clear only this sub-registry. For example, you can use the following command to remove all the classes and functions registered in the sub-registry <code>other</code>:</p> <pre><code>from objectory import Registry\n\nregistry = Registry()\n\nregistry.other.clear()\nprint(registry.other.registered_names())\n</code></pre> <p>Output:</p> <pre><code>set()\n</code></pre> <p>Note that by default, the function <code>clear</code> removes the sub-registries from the current registry but it does not clear the sub-registries.</p> <pre><code># file: my_package/my_module.py\nfrom objectory import Registry\n\nregistry = Registry()\n\n\nclass ClassToRegister:\n    pass\n\n\nregistry.other.register_object(ClassToRegister)\nregistry_other = registry.other\n\nregistry.clear()\nprint(registry.registered_names())\nprint(registry_other.registered_names())\n</code></pre> <p>Output:</p> <pre><code>set()\n{'my_package.my_module.ClassToRegister'}\n</code></pre> <p>To also clear all the sub-registries, you can set <code>nested=True</code> and the sub-registry <code>other</code> is also cleared.</p> <pre><code># file: my_package/my_module.py\nfrom objectory import Registry\n\nregistry = Registry()\n\n\nclass ClassToRegister:\n    pass\n\n\nregistry.other.register_object(ClassToRegister)\nregistry_other = registry.other\n\nregistry.clear(nested=True)\nprint(registry.registered_names())\nprint(registry_other.registered_names())\n</code></pre> <p>Output:</p> <pre><code>set()\nset()\n</code></pre>"},{"location":"registry/#remove-a-specific-object","title":"Remove a specific object","text":"<p>The function <code>clear</code> is useful to remove all the objects in the registry, but it does not work if you want to only remove a registered object and keep all the other registered objects.</p> <pre><code># file: my_package/my_module.py\nfrom objectory import Registry\n\nregistry = Registry()\n\n\n@registry.register()\nclass ClassToRegister1:\n    pass\n\n\n@registry.register()\nclass ClassToRegister2:\n    pass\n\n\nprint(registry.registered_names())\nregistry.unregister(\"my_package.my_module.ClassToRegister1\")\nprint(registry.registered_names())\n</code></pre> <p>Output:</p> <pre><code>{'my_package.my_module.ClassToRegister1', 'my_package.my_module.ClassToRegister2'}\n{'my_package.my_module.ClassToRegister2'}\n</code></pre> <p>If the object name is unique in the registry, you can only specify the object name:</p> <pre><code>from objectory import Registry\n\nregistry = Registry()\n\nregistry.unregister(\"ClassToRegister\")\n# is equivalent to\nregistry.unregister(\"my_package.my_module.ClassToRegister\")\n</code></pre> <p>Please read the name resolution documentation to learn more about this feature.</p>"},{"location":"registry/#filters","title":"Filters","text":""},{"location":"registry/#child-class-filter","title":"Child class filter","text":"<p>Usually you want to control the objects that you want to add to the registry. For example, it is usually a good idea to register similar objects in the same registry. A usual scenario is to define a base class, and then register only the child classes of the base class. For example if you want to register <code>torch.nn.Module</code>, you probably want to check that the object is a <code>torch.nn.Module</code> before to register it. Let's imagine you want to register only <code>torch.nn.Module</code> in the sub-registry <code>other</code>.</p> <pre><code>import torch\nfrom objectory import Registry\n\nregistry = Registry()\n\nregistry.set_class_filter(torch.nn.Module)\nregistry.register_object(torch.nn.Linear)\nregistry.register_object(torch.nn.Conv2d)\n...\n</code></pre> <p>You can only register classes that inherits torch.nn.Module in the sub-registry <code>other</code>. If you try to register a class which is not a child class, the registry will raise the exception <code>IncorrectObjectFactoryError</code>:</p> <pre><code>import torch\nfrom objectory import Registry\n\nregistry = Registry()\n\n\nclass Foo:\n    pass\n\n\nregistry.set_class_filter(torch.nn.Module)\nregistry.register_object(Foo)\n</code></pre> <p>The previous example will raise an exception because <code>Foo</code> is not a child class of <code>torch.nn.Module</code>. To unset the class filter, you can set it to <code>None</code>:</p> <pre><code>from objectory import Registry\n\nregistry = Registry()\nregistry.set_class_filter(None)\n</code></pre> <p> Note that the class filter is only used when you try to register a new object. It will not filter the existing objects into the registry. You can look at the following example:</p> <pre><code># file: my_package/my_module.py\nimport torch\n\nfrom objectory import Registry\n\n\nclass Foo:\n    pass\n\n\nregistry = Registry()\nregistry.register_object(Foo)\nprint(registry.registered_names())\n\nregistry.set_class_filter(torch.nn.Module)\nregistry.register_object(torch.nn.Linear)\nprint(registry.registered_names())\n</code></pre> <p>Output:</p> <pre><code>{'my_package.my_module.Foo'}\n{'my_package.my_module.Foo', 'torch.nn.Linear'}\n</code></pre> <p>You can see that the class <code>my_package.my_module.Foo</code> is still registered after the filter is set to <code>torch.nn.Module</code>. It is because this class was added before to set the class filter. If you want to filter all the objects before to add them to the registry, please set the class filter before to register the first object. It will guarantee that all the registered objects are inherited from the filtered class.</p>"},{"location":"registry/#clear-all-filters","title":"Clear all filters","text":"<p>You can remove all the filters of a registry by using the function <code>clear_filters</code>:</p> <pre><code>from objectory import Registry\n\nregistry = Registry()\nregistry.clear_filters()\n</code></pre> <p>By default, the function <code>clear_filters</code> removes the filters on the current registry but not the filters of the sub-registries. To also remove the filters of all the sub-registries, you can set <code>nested=True</code>:</p> <pre><code>from objectory import Registry\n\nregistry = Registry()\nregistry.clear_filters(nested=True)\n</code></pre>"},{"location":"universal_factory/","title":"Universal Factory","text":"<p>The universal factory is the simplest way to use objectory. It provides a single <code>factory()</code> function that can instantiate any Python object by its fully qualified name, without requiring prior registration.</p>"},{"location":"universal_factory/#basic-usage","title":"Basic Usage","text":"<p>The <code>factory()</code> function takes a target string and optional arguments:</p> <pre><code>from objectory import factory\n\n# Create a Counter from collections\ncounter = factory(\"collections.Counter\", [1, 2, 1, 3])\nprint(counter)  # Counter({1: 2, 2: 1, 3: 1})\n\n# Create a Path object\npath = factory(\"pathlib.Path\", \"/tmp/data\")\nprint(path)  # /tmp/data\n</code></pre>"},{"location":"universal_factory/#function-signature","title":"Function Signature","text":"<pre><code>def factory(\n        _target_: str,\n        *args: Any,\n        _init_: str = \"__init__\",\n        **kwargs: Any\n) -&gt; Any\n</code></pre>"},{"location":"universal_factory/#parameters","title":"Parameters","text":"<ul> <li>target (str): The fully qualified name of the object (class or function) to instantiate<ul> <li>Examples: <code>\"collections.Counter\"</code>, <code>\"pathlib.Path\"</code>, <code>\"builtins.list\"</code></li> </ul> </li> <li>*args: Positional arguments to pass to the constructor or function</li> <li>init (str, optional): The initialization method to use (default: <code>\"__init__\"</code>)<ul> <li>Can be <code>\"__init__\"</code>, <code>\"__new__\"</code>, or the name of a class method</li> </ul> </li> <li>**kwargs: Keyword arguments to pass to the constructor or function</li> </ul>"},{"location":"universal_factory/#returns","title":"Returns","text":"<p>The instantiated object with the given parameters.</p>"},{"location":"universal_factory/#raises","title":"Raises","text":"<ul> <li>RuntimeError: If the target cannot be found or imported</li> </ul>"},{"location":"universal_factory/#examples","title":"Examples","text":""},{"location":"universal_factory/#creating-standard-library-objects","title":"Creating Standard Library Objects","text":"<pre><code>from objectory import factory\n\n# Lists and collections\nmy_list = factory(\"builtins.list\", [1, 2, 3])\nmy_set = factory(\"builtins.set\", [1, 2, 2, 3])\ndeque = factory(\"collections.deque\", [1, 2, 3], maxlen=5)\n\n# Dictionaries\ncounter = factory(\"collections.Counter\", [1, 2, 1])\nordered_dict = factory(\"collections.OrderedDict\", [(\"a\", 1), (\"b\", 2)])\ndefault_dict = factory(\"collections.defaultdict\", list)\n\n# Path objects\npath = factory(\"pathlib.Path\", \"/tmp/example\")\n</code></pre>"},{"location":"universal_factory/#using-keyword-arguments","title":"Using Keyword Arguments","text":"<pre><code>from objectory import factory\n\n# Create objects with keyword arguments\nordered_dict = factory(\"collections.OrderedDict\", a=1, b=2, c=3)\n\n# Mix positional and keyword arguments\ndeque = factory(\"collections.deque\", [1, 2, 3], maxlen=5)\n</code></pre>"},{"location":"universal_factory/#using-custom-initialization-methods","title":"Using Custom Initialization Methods","text":"<p>You can specify a different initialization method using the <code>_init_</code> parameter:</p> <pre><code>from objectory import factory\n\n\nclass MyClass:\n    def __init__(self, value: int):\n        self.value = value\n\n    @classmethod\n    def from_string(cls, s: str):\n        return cls(int(s))\n\n    @classmethod\n    def default(cls):\n        return cls(0)\n\n\n# Register the class (for this example, we'll use it directly)\n# In practice, you'd have it in a module\n\n# Using default constructor\nobj1 = factory(\"__main__.MyClass\", 42)\n\n# Using class method\nobj2 = factory(\"__main__.MyClass\", \"42\", _init_=\"from_string\")\n\n# Using default factory method\nobj3 = factory(\"__main__.MyClass\", _init_=\"default\")\n</code></pre>"},{"location":"universal_factory/#comparison-with-other-approaches","title":"Comparison with Other Approaches","text":""},{"location":"universal_factory/#universal-factory-vs-abstractfactory","title":"Universal Factory vs AbstractFactory","text":"<p>Universal Factory:</p> <ul> <li>\u2705 No registration needed</li> <li>\u2705 Works with any importable object</li> <li>\u2705 Simple to use</li> <li>\u274c No inheritance-based organization</li> <li>\u274c No automatic discovery</li> </ul> <p>AbstractFactory:</p> <ul> <li>\u2705 Automatic registration through inheritance</li> <li>\u2705 Organized object families</li> <li>\u2705 Supports short names</li> <li>\u274c Requires metaclass</li> <li>\u274c More setup required</li> </ul>"},{"location":"universal_factory/#universal-factory-vs-registry","title":"Universal Factory vs Registry","text":"<p>Universal Factory:</p> <ul> <li>\u2705 No registration needed</li> <li>\u2705 Works immediately</li> <li>\u2705 Simple API</li> <li>\u274c No filters or validation</li> <li>\u274c No sub-registries</li> </ul> <p>Registry:</p> <ul> <li>\u2705 Fine-grained control</li> <li>\u2705 Sub-registries for organization</li> <li>\u2705 Class filters</li> <li>\u274c Manual registration required</li> <li>\u274c More complex</li> </ul>"},{"location":"universal_factory/#when-to-use-universal-factory","title":"When to Use Universal Factory","text":"<p>Use the universal factory when:</p> <ul> <li>You need to instantiate objects from configuration files</li> <li>You want a simple, no-setup solution</li> <li>You're working with third-party libraries</li> <li>You don't need object organization or validation</li> <li>You have fully qualified names available</li> </ul>"},{"location":"universal_factory/#configuration-file-integration","title":"Configuration File Integration","text":"<p>The universal factory works great with YAML/JSON configuration files:</p> <p>config.yaml:</p> <pre><code>database:\n  _target_: collections.OrderedDict\n  host: localhost\n  port: 5432\n  database: myapp\n\ncache:\n  _target_: collections.defaultdict\n  default_factory: int\n</code></pre> <p>Loading configuration:</p> <pre><code>import yaml\nfrom objectory import factory\n\nwith open(\"config.yaml\") as f:\n    config = yaml.safe_load(f)\n\n# Create database config\ndb = factory(**config[\"database\"])\nprint(db)  # OrderedDict([('host', 'localhost'), ('port', 5432), ...])\n\n# Create cache\ncache = factory(**config[\"cache\"])\nprint(type(cache))  # &lt;class 'collections.defaultdict'&gt;\n</code></pre>"},{"location":"universal_factory/#best-practices","title":"Best Practices","text":""},{"location":"universal_factory/#1-use-full-qualified-names","title":"1. Use Full Qualified Names","text":"<p>Always use the full module path to avoid ambiguity:</p> <pre><code># Good\nfactory(\"collections.Counter\")\n\n# Avoid (may not work)\nfactory(\"Counter\")\n</code></pre>"},{"location":"universal_factory/#2-validate-input-for-security","title":"2. Validate Input for Security","text":"<p>Never use untrusted user input directly with the factory:</p> <pre><code># BAD - Security risk!\nuser_input = request.get(\"class\")\nobj = factory(user_input)\n\n# GOOD - Validate against allowlist\nALLOWED_CLASSES = {\"collections.Counter\", \"collections.defaultdict\"}\nuser_input = request.get(\"class\")\nif user_input not in ALLOWED_CLASSES:\n    raise ValueError(\"Class not allowed\")\nobj = factory(user_input)\n</code></pre>"},{"location":"universal_factory/#3-handle-errors-gracefully","title":"3. Handle Errors Gracefully","text":"<p>The factory raises <code>RuntimeError</code> if the target cannot be found:</p> <pre><code>from objectory import factory\n\ntry:\n    obj = factory(\"non.existent.Module\")\nexcept RuntimeError as e:\n    print(f\"Failed to create object: {e}\")\n</code></pre>"},{"location":"universal_factory/#4-document-configuration-schema","title":"4. Document Configuration Schema","text":"<p>When using with configuration files, document the expected structure:</p> <pre><code>\"\"\"\nConfiguration schema:\n\ndatabase:\n  _target_: str          # Fully qualified class name\n  host: str              # Database host\n  port: int              # Database port\n  database: str          # Database name\n\"\"\"\n</code></pre>"},{"location":"universal_factory/#advanced-usage","title":"Advanced Usage","text":""},{"location":"universal_factory/#creating-custom-factory-wrappers","title":"Creating Custom Factory Wrappers","text":"<p>You can create type-safe wrappers around the universal factory:</p> <pre><code>from typing import Any\nfrom objectory import factory\nfrom pathlib import Path\n\n\ndef create_path(path_str: str, **kwargs: Any) -&gt; Path:\n    \"\"\"Create a Path object.\"\"\"\n    return factory(\"pathlib.Path\", path_str, **kwargs)\n\n\ndef create_counter(items: list, **kwargs: Any):\n    \"\"\"Create a Counter object.\"\"\"\n    return factory(\"collections.Counter\", items, **kwargs)\n\n\n# Usage\npath = create_path(\"/tmp/data\")\ncounter = create_counter([1, 2, 1, 3])\n</code></pre>"},{"location":"universal_factory/#lazy-object-creation","title":"Lazy Object Creation","text":"<p>Create a factory function that delays instantiation:</p> <pre><code>from typing import Any, Callable\nfrom objectory import factory\n\n\ndef lazy_factory(target: str, *args: Any, **kwargs: Any) -&gt; Callable:\n    \"\"\"Return a function that creates the object when called.\"\"\"\n\n    def create():\n        return factory(target, *args, **kwargs)\n\n    return create\n\n\n# Create lazy constructors\ncreate_counter = lazy_factory(\"collections.Counter\", [1, 2, 3])\ncreate_path = lazy_factory(\"pathlib.Path\", \"/tmp\")\n\n# Instantiate when needed\ncounter = create_counter()\npath = create_path()\n</code></pre>"},{"location":"universal_factory/#limitations","title":"Limitations","text":"<ol> <li>No object discovery: The factory cannot list available objects</li> <li>No validation: The factory doesn't validate if objects are compatible</li> <li>Requires full names: Short names are not supported (use AbstractFactory or Registry for that)</li> <li>No caching: Each call creates a new object instance</li> </ol>"},{"location":"universal_factory/#see-also","title":"See Also","text":"<ul> <li>AbstractFactory - For inheritance-based factories</li> <li>Registry - For manual registration with more control</li> <li>Name Resolution - Understanding how names are resolved</li> </ul>"},{"location":"refs/","title":"Main classes and functions","text":""},{"location":"refs/#objectory","title":"objectory","text":"<p>Contain the main features of the <code>objectory</code> package.</p>"},{"location":"refs/#objectory.AbstractFactory","title":"objectory.AbstractFactory","text":"<p>               Bases: <code>ABCMeta</code></p> <p>Implement the abstract factory metaclass to create factories automatically.</p> <p>Please read the documentation about this abstract factory to learn how it works and how to use it.</p> <p>To avoid potential conflicts with the other classes, all the non-public attributes or functions starts with <code>_abstractfactory_****</code> where <code>****</code> is the name of the attribute or the function.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The class name. This becomes the <code>__name__</code> attribute of the class.</p> required <code>bases</code> <code>tuple</code> <p>A tuple of the base classes from which the class inherits. This becomes the <code>__bases__</code> attribute of the class.</p> required <code>dct</code> <code>dict</code> <p>A namespace dictionary containing definitions for the class body. This becomes the <code>__dict__</code> attribute of the class.</p> required <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from objectory import AbstractFactory\n&gt;&gt;&gt; class BaseClass(metaclass=AbstractFactory):\n...     pass\n...\n&gt;&gt;&gt; class MyClass(BaseClass):\n...     pass\n...\n&gt;&gt;&gt; obj = BaseClass.factory(\"MyClass\")\n&gt;&gt;&gt; obj\n&lt;....MyClass object at 0x...&gt;\n</code></pre>"},{"location":"refs/#objectory.AbstractFactory.inheritors","title":"objectory.AbstractFactory.inheritors  <code>property</code>","text":"<pre><code>inheritors: dict[str, Any]\n</code></pre> <p>Get the inheritors.</p> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>The inheritors.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from objectory import AbstractFactory\n&gt;&gt;&gt; class BaseClass(metaclass=AbstractFactory):\n...     pass\n...\n&gt;&gt;&gt; class MyClass(BaseClass):\n...     pass\n...\n&gt;&gt;&gt; BaseClass.inheritors\n{'....BaseClass': &lt;class '....BaseClass'&gt;, '....MyClass': &lt;class '....MyClass'&gt;}\n</code></pre>"},{"location":"refs/#objectory.AbstractFactory.factory","title":"objectory.AbstractFactory.factory","text":"<pre><code>factory(\n    _target_: str,\n    *args: Any,\n    _init_: str = \"__init__\",\n    **kwargs: Any\n) -&gt; Any\n</code></pre> <p>Instantiate dynamically an object given its configuration.</p> <p>This method creates an instance of a registered class or calls a registered function. The target can be specified using either the short name (e.g., \"MyClass\") or the fully qualified name (e.g., \"mymodule.MyClass\"). If the target is not yet registered, it will attempt to import and register it automatically.</p> <p>Parameters:</p> Name Type Description Default <code>_target_</code> <code>str</code> <p>The name of the object (class or function) to instantiate. It can be the class name or the full class name. Supports name resolution for registered objects.</p> required <code>*args</code> <code>Any</code> <p>Positional arguments to pass to the class constructor or function.</p> <code>()</code> <code>_init_</code> <code>str</code> <p>The function or method to use to create the object. If <code>\"__init__\"</code> (default), the object is created by calling the constructor. Can also be <code>\"__new__\"</code> or the name of a class method.</p> <code>'__init__'</code> <code>**kwargs</code> <code>Any</code> <p>Keyword arguments to pass to the class constructor or function.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Any</code> <p>The instantiated object with the given parameters.</p> <p>Raises:</p> Type Description <code>AbstractClassAbstractFactoryError</code> <p>when an abstract class is instantiated.</p> <code>UnregisteredClassAbstractFactoryError</code> <p>when the target is not found.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from objectory import AbstractFactory\n&gt;&gt;&gt; class BaseClass(metaclass=AbstractFactory):\n...     pass\n...\n&gt;&gt;&gt; class MyClass(BaseClass):\n...     pass\n...\n&gt;&gt;&gt; obj = BaseClass.factory(\"MyClass\")\n&gt;&gt;&gt; obj\n&lt;....MyClass object at 0x...&gt;\n</code></pre>"},{"location":"refs/#objectory.AbstractFactory.register_object","title":"objectory.AbstractFactory.register_object","text":"<pre><code>register_object(obj: type | Callable) -&gt; None\n</code></pre> <p>Register a class or function to the factory.</p> <p>This method manually registers a class or function with the factory, making it available for instantiation. This is particularly useful when working with third-party libraries where you cannot modify the source code to inherit from the factory. The object is registered using its fully qualified name. If an object with the same name already exists, it will be replaced with a warning.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>type | Callable</code> <p>The class or function to register to the factory. Must be a valid class or function object (not a lambda function).</p> required <p>Raises:</p> Type Description <code>IncorrectObjectAbstractFactoryError</code> <p>if the object is not a class or function, or if it is a lambda function.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from objectory import AbstractFactory\n&gt;&gt;&gt; class BaseClass(metaclass=AbstractFactory):\n...     pass\n...\n&gt;&gt;&gt; class MyClass:\n...     pass\n...\n&gt;&gt;&gt; BaseClass.register_object(MyClass)\n&gt;&gt;&gt; BaseClass.inheritors\n{...}\n</code></pre>"},{"location":"refs/#objectory.AbstractFactory.unregister","title":"objectory.AbstractFactory.unregister","text":"<pre><code>unregister(name: str) -&gt; None\n</code></pre> <p>Remove a registered object from the factory.</p> <p>This method removes a class or function from the factory's registry. The object will no longer be available for instantiation through the factory. This is an experimental function and may change in the future.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the object to remove. Can be either the short name (e.g., \"MyClass\") or the fully qualified name (e.g., \"mymodule.MyClass\"). This function uses the name resolution mechanism to find the full name if only the short name is given.</p> required <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from objectory import AbstractFactory\n&gt;&gt;&gt; class BaseClass(metaclass=AbstractFactory):\n...     pass\n...\n&gt;&gt;&gt; class MyClass:\n...     pass\n...\n&gt;&gt;&gt; BaseClass.register_object(MyClass)\n&gt;&gt;&gt; BaseClass.unregister(\"MyClass\")\n&gt;&gt;&gt; BaseClass.inheritors\n{'....BaseClass': &lt;class '....BaseClass'&gt;}\n</code></pre>"},{"location":"refs/#objectory.Registry","title":"objectory.Registry","text":"<p>Implement the registry class.</p> <p>This class can be used to register some objects and instantiate an object from its configuration.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from objectory import Registry\n&gt;&gt;&gt; from collections import Counter\n&gt;&gt;&gt; registry = Registry()\n&gt;&gt;&gt; registry.register_object(Counter)\n&gt;&gt;&gt; registry.factory(\"collections.Counter\")\nCounter()\n</code></pre>"},{"location":"refs/#objectory.Registry.__getattr__","title":"objectory.Registry.__getattr__","text":"<pre><code>__getattr__(key: str) -&gt; Registry | type\n</code></pre> <p>Get the registry associated to a key.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The key.</p> required <p>Returns:</p> Type Description <code>Registry | type</code> <p>The registry associated to the key.</p> <p>Raises:</p> Type Description <code>InvalidAttributeRegistryError</code> <p>if the associated attribute is not a registry.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from collections import Counter\n&gt;&gt;&gt; registry = Registry()\n&gt;&gt;&gt; registry.other.register_object(Counter)\n</code></pre>"},{"location":"refs/#objectory.Registry.__len__","title":"objectory.Registry.__len__","text":"<pre><code>__len__() -&gt; int\n</code></pre> <p>Return the number of registered objects.</p> <p>Returns:</p> Type Description <code>int</code> <p>The number of registered objects.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from objectory import Registry\n&gt;&gt;&gt; from collections import Counter\n&gt;&gt;&gt; registry = Registry()\n&gt;&gt;&gt; registry.register_object(Counter)\n&gt;&gt;&gt; len(registry)\n1\n</code></pre>"},{"location":"refs/#objectory.Registry.clear","title":"objectory.Registry.clear","text":"<pre><code>clear(nested: bool = False) -&gt; None\n</code></pre> <p>Clear the registry.</p> <p>This functions removes all the registered objects in the registry.</p> <p>Parameters:</p> Name Type Description Default <code>nested</code> <code>bool</code> <p>Indicates if the sub-registries should be cleared or not.</p> <code>False</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from objectory import Registry\n&gt;&gt;&gt; registry = Registry()\n&gt;&gt;&gt; # Clear the main registry.\n&gt;&gt;&gt; registry.clear()\n&gt;&gt;&gt; # Clear only the sub-registry other.\n&gt;&gt;&gt; registry.other.clear()\n&gt;&gt;&gt; # Clear the main registry and its sub-registries.\n&gt;&gt;&gt; registry.clear(nested=True)\n</code></pre>"},{"location":"refs/#objectory.Registry.clear_filters","title":"objectory.Registry.clear_filters","text":"<pre><code>clear_filters(nested: bool = False) -&gt; None\n</code></pre> <p>Clear all the filters of the registry.</p> <p>Parameters:</p> Name Type Description Default <code>nested</code> <code>bool</code> <p>Indicates if the filters of all the sub-registries should be cleared or not.</p> <code>False</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from objectory import Registry\n&gt;&gt;&gt; registry = Registry()\n&gt;&gt;&gt; # Clear the filters of the main registry.\n&gt;&gt;&gt; registry.clear_filters()\n&gt;&gt;&gt; # Clear the filters of the sub-registry other.\n&gt;&gt;&gt; registry.other.clear_filters()\n&gt;&gt;&gt; # Clear the filters of the main registry and all its sub-registries.\n&gt;&gt;&gt; registry.clear_filters(nested=True)\n</code></pre>"},{"location":"refs/#objectory.Registry.factory","title":"objectory.Registry.factory","text":"<pre><code>factory(\n    _target_: str,\n    *args: Any,\n    _init_: str = \"__init__\",\n    **kwargs: Any\n) -&gt; Any\n</code></pre> <p>Instantiate dynamically an object given its configuration.</p> <p>This method creates an instance of a registered class or calls a registered function. The target can be specified using either the short name or the fully qualified name. If the target is not yet registered, it will attempt to import and register it automatically.</p> <p>Parameters:</p> Name Type Description Default <code>_target_ </code> <p>The name of the object (class or function) to instantiate. It can be the class name or the full class name. Supports name resolution for registered objects.</p> required <code>*args</code> <code>Any</code> <p>Positional arguments to pass to the class constructor or function.</p> <code>()</code> <code>_init_</code> <code>str</code> <p>The function or method to use to create the object. If <code>\"__init__\"</code> (default), the object is created by calling the constructor. Can also be <code>\"__new__\"</code> or the name of a class method.</p> <code>'__init__'</code> <code>**kwargs</code> <code>Any</code> <p>Keyword arguments to pass to the class constructor or function.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Any</code> <p>The instantiated object with the given parameters.</p> <p>Raises:</p> Type Description <code>AbstractClassAbstractFactoryError</code> <p>when an abstract class is instantiated.</p> <code>UnregisteredClassAbstractFactoryError</code> <p>if the target name is not found.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from objectory import Registry\n&gt;&gt;&gt; registry = Registry()\n&gt;&gt;&gt; @registry.register()\n... class MyClass:\n...     pass\n...\n&gt;&gt;&gt; registry.factory(\"MyClass\")\n&lt;....MyClass object at 0x...&gt;\n</code></pre>"},{"location":"refs/#objectory.Registry.register","title":"objectory.Registry.register","text":"<pre><code>register(name: str | None = None) -&gt; Callable\n</code></pre> <p>Define a decorator to add a class or a function to the registry.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str | None</code> <p>The name to use to register the object. If <code>None</code>, the full name of the object is used as name.</p> <code>None</code> <p>Returns:</p> Type Description <code>Callable</code> <p>The decorated object.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from objectory import Registry\n&gt;&gt;&gt; registry = Registry()\n&gt;&gt;&gt; @registry.register()\n... class ClassToRegister:\n...     pass\n...\n&gt;&gt;&gt; registry.registered_names()\n{'....ClassToRegister'}\n&gt;&gt;&gt; @registry.register()\n... def function_to_register(*args, **kwargs):\n...     pass\n...\n&gt;&gt;&gt; registry.registered_names()\n{...}\n</code></pre>"},{"location":"refs/#objectory.Registry.register_child_classes","title":"objectory.Registry.register_child_classes","text":"<pre><code>register_child_classes(\n    cls: type, ignore_abstract_class: bool = True\n) -&gt; None\n</code></pre> <p>Register a given class and its child classes.</p> <p>This function registers all the child classes including the child classes of the child classes, etc. If you use this function, you cannot choose the names used to register the objects. It will use the fully qualified name of each object.</p> <p>Parameters:</p> Name Type Description Default <code>cls</code> <code>type</code> <p>The class to register along with its child classes.</p> required <code>ignore_abstract_class</code> <code>bool</code> <p>Indicate if the abstract classes should be ignored or not. By default, the abstract classes are not registered because they cannot be instantiated.</p> <code>True</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from objectory import Registry\n&gt;&gt;&gt; registry = Registry()\n&gt;&gt;&gt; registry.register_child_classes(dict)\n&gt;&gt;&gt; registry.registered_names()\n{...}\n</code></pre>"},{"location":"refs/#objectory.Registry.register_object","title":"objectory.Registry.register_object","text":"<pre><code>register_object(\n    obj: type | Callable, name: str | None = None\n) -&gt; None\n</code></pre> <p>Register an object.</p> <p>This method adds a class or function to the registry, making it available for instantiation through the factory method. You can optionally specify a custom name for the object; otherwise, its fully qualified name will be used. If a class filter is set, the object must be a subclass of the filter class.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>type | Callable</code> <p>The object to register. The object must be a class or a function (not a lambda function).</p> required <code>name</code> <code>str | None</code> <p>The name to use to register the object. If <code>None</code>, the fully qualified name of the object is used. Cannot conflict with sub-registry names.</p> <code>None</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from objectory import Registry\n&gt;&gt;&gt; registry = Registry()\n&gt;&gt;&gt; class ClassToRegister:\n...     pass\n...\n&gt;&gt;&gt; registry.register_object(ClassToRegister)\n&gt;&gt;&gt; registry.registered_names()\n{'....ClassToRegister'}\n&gt;&gt;&gt; def function_to_register(*args, **kwargs):\n...     pass\n...\n&gt;&gt;&gt; registry.register_object(function_to_register)\n&gt;&gt;&gt; registry.registered_names()\n{...}\n</code></pre>"},{"location":"refs/#objectory.Registry.registered_names","title":"objectory.Registry.registered_names","text":"<pre><code>registered_names(include_registry: bool = True) -&gt; set[str]\n</code></pre> <p>Get the names of all the registered objects.</p> <p>Parameters:</p> Name Type Description Default <code>include_registry</code> <code>bool</code> <p>Indicates if the other (sub-)registries should be included in the set. By default, the other (sub-)registries are included.</p> <code>True</code> <p>Returns:</p> Type Description <code>set[str]</code> <p>The names of the registered objects.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from objectory import Registry\n&gt;&gt;&gt; registry = Registry()\n&gt;&gt;&gt; registry.registered_names()\n&gt;&gt;&gt; # Show name of all the registered objects except the sub-registries.\n&gt;&gt;&gt; registry.registered_names(include_registry=False)\n</code></pre>"},{"location":"refs/#objectory.Registry.set_class_filter","title":"objectory.Registry.set_class_filter","text":"<pre><code>set_class_filter(cls: type | None) -&gt; None\n</code></pre> <p>Set the class filter so only the child classes of this class can be registered.</p> <p>If you set this filter, you cannot register functions. To unset this filter, you can use <code>set_class_filter(None)</code>.</p> <p>Parameters:</p> Name Type Description Default <code>cls</code> <code>type | None</code> <p>The class to use as filter. Only the child classes of this class can be registered.</p> required <p>Raises:</p> Type Description <code>TypeError</code> <p>if the input is not a class or <code>None</code>.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from collections import Counter, OrderedDict\n&gt;&gt;&gt; from objectory import Registry\n&gt;&gt;&gt; registry = Registry()\n&gt;&gt;&gt; registry.mapping.set_class_filter(dict)\n&gt;&gt;&gt; registry.mapping.register_object(OrderedDict)\n&gt;&gt;&gt; registry.mapping.registered_names()\n{'collections.OrderedDict'}\n</code></pre>"},{"location":"refs/#objectory.Registry.unregister","title":"objectory.Registry.unregister","text":"<pre><code>unregister(name: str) -&gt; None\n</code></pre> <p>Remove a registered object.</p> <p>This method removes a class or function from the registry. The object will no longer be available for instantiation through the factory method.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the object to remove. Can be either the short name or the fully qualified name. This function uses the name resolution mechanism to find the full name if only the short name is given.</p> required <p>Raises:</p> Type Description <code>UnregisteredObjectFactoryError</code> <p>if the name does not exist in the registry.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from objectory import Registry\n&gt;&gt;&gt; from collections import Counter\n&gt;&gt;&gt; registry = Registry()\n&gt;&gt;&gt; registry.register_object(Counter)\n&gt;&gt;&gt; registry.unregister(\"collections.Counter\")\n</code></pre>"},{"location":"refs/#objectory.factory","title":"objectory.factory","text":"<pre><code>factory(\n    _target_: str,\n    *args: Any,\n    _init_: str = \"__init__\",\n    **kwargs: Any\n) -&gt; Any\n</code></pre> <p>Instantiate dynamically an object given its configuration.</p> <p>This function provides a universal factory that can instantiate any class or call any function by its fully qualified name. Unlike the AbstractFactory or Registry approaches, this function does not require prior registration of classes.</p> <p>Parameters:</p> Name Type Description Default <code>_target_</code> <code>str</code> <p>The fully qualified name of the object (class or function) to instantiate, e.g., \"collections.Counter\" or \"math.isclose\".</p> required <code>*args</code> <code>Any</code> <p>Positional arguments to pass to the class constructor or function.</p> <code>()</code> <code>_init_</code> <code>str</code> <p>The function or method to use to create the object. If <code>\"__init__\"</code> (default), the object is created by calling the constructor. Can also be <code>\"__new__\"</code> or the name of a class method.</p> <code>'__init__'</code> <code>**kwargs</code> <code>Any</code> <p>Keyword arguments to pass to the class constructor or function.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Any</code> <p>The instantiated object with the given parameters.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>if the target cannot be found.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from objectory import factory\n&gt;&gt;&gt; factory(\"collections.Counter\", [1, 2, 1, 3])\nCounter({1: 2, 2: 1, 3: 1})\n</code></pre>"},{"location":"refs/abstract_factory/","title":"Abstract factory","text":""},{"location":"refs/abstract_factory/#objectory.abstract_factory","title":"objectory.abstract_factory","text":"<p>Implement the <code>AbstractFactory</code> metaclass used to create abstract factories.</p> <p>This module provides an abstract factory implementation that allows automatic registration and instantiation of classes and functions.</p>"},{"location":"refs/abstract_factory/#objectory.abstract_factory.AbstractFactory","title":"objectory.abstract_factory.AbstractFactory","text":"<p>               Bases: <code>ABCMeta</code></p> <p>Implement the abstract factory metaclass to create factories automatically.</p> <p>Please read the documentation about this abstract factory to learn how it works and how to use it.</p> <p>To avoid potential conflicts with the other classes, all the non-public attributes or functions starts with <code>_abstractfactory_****</code> where <code>****</code> is the name of the attribute or the function.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The class name. This becomes the <code>__name__</code> attribute of the class.</p> required <code>bases</code> <code>tuple</code> <p>A tuple of the base classes from which the class inherits. This becomes the <code>__bases__</code> attribute of the class.</p> required <code>dct</code> <code>dict</code> <p>A namespace dictionary containing definitions for the class body. This becomes the <code>__dict__</code> attribute of the class.</p> required <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from objectory import AbstractFactory\n&gt;&gt;&gt; class BaseClass(metaclass=AbstractFactory):\n...     pass\n...\n&gt;&gt;&gt; class MyClass(BaseClass):\n...     pass\n...\n&gt;&gt;&gt; obj = BaseClass.factory(\"MyClass\")\n&gt;&gt;&gt; obj\n&lt;....MyClass object at 0x...&gt;\n</code></pre>"},{"location":"refs/abstract_factory/#objectory.abstract_factory.AbstractFactory.inheritors","title":"objectory.abstract_factory.AbstractFactory.inheritors  <code>property</code>","text":"<pre><code>inheritors: dict[str, Any]\n</code></pre> <p>Get the inheritors.</p> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>The inheritors.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from objectory import AbstractFactory\n&gt;&gt;&gt; class BaseClass(metaclass=AbstractFactory):\n...     pass\n...\n&gt;&gt;&gt; class MyClass(BaseClass):\n...     pass\n...\n&gt;&gt;&gt; BaseClass.inheritors\n{'....BaseClass': &lt;class '....BaseClass'&gt;, '....MyClass': &lt;class '....MyClass'&gt;}\n</code></pre>"},{"location":"refs/abstract_factory/#objectory.abstract_factory.AbstractFactory.factory","title":"objectory.abstract_factory.AbstractFactory.factory","text":"<pre><code>factory(\n    _target_: str,\n    *args: Any,\n    _init_: str = \"__init__\",\n    **kwargs: Any\n) -&gt; Any\n</code></pre> <p>Instantiate dynamically an object given its configuration.</p> <p>This method creates an instance of a registered class or calls a registered function. The target can be specified using either the short name (e.g., \"MyClass\") or the fully qualified name (e.g., \"mymodule.MyClass\"). If the target is not yet registered, it will attempt to import and register it automatically.</p> <p>Parameters:</p> Name Type Description Default <code>_target_</code> <code>str</code> <p>The name of the object (class or function) to instantiate. It can be the class name or the full class name. Supports name resolution for registered objects.</p> required <code>*args</code> <code>Any</code> <p>Positional arguments to pass to the class constructor or function.</p> <code>()</code> <code>_init_</code> <code>str</code> <p>The function or method to use to create the object. If <code>\"__init__\"</code> (default), the object is created by calling the constructor. Can also be <code>\"__new__\"</code> or the name of a class method.</p> <code>'__init__'</code> <code>**kwargs</code> <code>Any</code> <p>Keyword arguments to pass to the class constructor or function.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Any</code> <p>The instantiated object with the given parameters.</p> <p>Raises:</p> Type Description <code>AbstractClassAbstractFactoryError</code> <p>when an abstract class is instantiated.</p> <code>UnregisteredClassAbstractFactoryError</code> <p>when the target is not found.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from objectory import AbstractFactory\n&gt;&gt;&gt; class BaseClass(metaclass=AbstractFactory):\n...     pass\n...\n&gt;&gt;&gt; class MyClass(BaseClass):\n...     pass\n...\n&gt;&gt;&gt; obj = BaseClass.factory(\"MyClass\")\n&gt;&gt;&gt; obj\n&lt;....MyClass object at 0x...&gt;\n</code></pre>"},{"location":"refs/abstract_factory/#objectory.abstract_factory.AbstractFactory.register_object","title":"objectory.abstract_factory.AbstractFactory.register_object","text":"<pre><code>register_object(obj: type | Callable) -&gt; None\n</code></pre> <p>Register a class or function to the factory.</p> <p>This method manually registers a class or function with the factory, making it available for instantiation. This is particularly useful when working with third-party libraries where you cannot modify the source code to inherit from the factory. The object is registered using its fully qualified name. If an object with the same name already exists, it will be replaced with a warning.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>type | Callable</code> <p>The class or function to register to the factory. Must be a valid class or function object (not a lambda function).</p> required <p>Raises:</p> Type Description <code>IncorrectObjectAbstractFactoryError</code> <p>if the object is not a class or function, or if it is a lambda function.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from objectory import AbstractFactory\n&gt;&gt;&gt; class BaseClass(metaclass=AbstractFactory):\n...     pass\n...\n&gt;&gt;&gt; class MyClass:\n...     pass\n...\n&gt;&gt;&gt; BaseClass.register_object(MyClass)\n&gt;&gt;&gt; BaseClass.inheritors\n{...}\n</code></pre>"},{"location":"refs/abstract_factory/#objectory.abstract_factory.AbstractFactory.unregister","title":"objectory.abstract_factory.AbstractFactory.unregister","text":"<pre><code>unregister(name: str) -&gt; None\n</code></pre> <p>Remove a registered object from the factory.</p> <p>This method removes a class or function from the factory's registry. The object will no longer be available for instantiation through the factory. This is an experimental function and may change in the future.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the object to remove. Can be either the short name (e.g., \"MyClass\") or the fully qualified name (e.g., \"mymodule.MyClass\"). This function uses the name resolution mechanism to find the full name if only the short name is given.</p> required <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from objectory import AbstractFactory\n&gt;&gt;&gt; class BaseClass(metaclass=AbstractFactory):\n...     pass\n...\n&gt;&gt;&gt; class MyClass:\n...     pass\n...\n&gt;&gt;&gt; BaseClass.register_object(MyClass)\n&gt;&gt;&gt; BaseClass.unregister(\"MyClass\")\n&gt;&gt;&gt; BaseClass.inheritors\n{'....BaseClass': &lt;class '....BaseClass'&gt;}\n</code></pre>"},{"location":"refs/abstract_factory/#objectory.abstract_factory.is_abstract_factory","title":"objectory.abstract_factory.is_abstract_factory","text":"<pre><code>is_abstract_factory(cls: Any) -&gt; bool\n</code></pre> <p>Indicate if a class implements the <code>AbstractFactory</code> metaclass.</p> <p>Parameters:</p> Name Type Description Default <code>cls</code> <code>Any</code> <p>The class to check.</p> required <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the class implements the <code>AbstractFactory</code> metaclass, otherwise <code>False</code>.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from objectory.abstract_factory import AbstractFactory, is_abstract_factory\n&gt;&gt;&gt; class BaseClass(metaclass=AbstractFactory):\n...     pass\n...\n&gt;&gt;&gt; is_abstract_factory(BaseClass)\nTrue\n&gt;&gt;&gt; is_abstract_factory(int)\nFalse\n</code></pre>"},{"location":"refs/abstract_factory/#objectory.abstract_factory.register","title":"objectory.abstract_factory.register","text":"<pre><code>register(cls: AbstractFactory) -&gt; Callable\n</code></pre> <p>Define a decorator to register a function to a factory.</p> <p>This decorator is designed to register functions that return an object of a class registered in the factory.</p> <p>Parameters:</p> Name Type Description Default <code>cls</code> <code>AbstractFactory</code> <p>The class where to register the function. Must be a class that uses the <code>AbstractFactory</code> metaclass.</p> required <p>Returns:</p> Type Description <code>Callable</code> <p>The decorated function.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from objectory.abstract_factory import AbstractFactory, register\n&gt;&gt;&gt; class BaseClass(metaclass=AbstractFactory):\n...     pass\n...\n&gt;&gt;&gt; @register(BaseClass)\n... def function_to_register(value: int) -&gt; int:\n...     return value + 2\n...\n&gt;&gt;&gt; BaseClass.factory(\"function_to_register\", 40)\n42\n</code></pre>"},{"location":"refs/abstract_factory/#objectory.abstract_factory.register_child_classes","title":"objectory.abstract_factory.register_child_classes","text":"<pre><code>register_child_classes(\n    factory_cls: AbstractFactory | type,\n    cls: type,\n    ignore_abstract_class: bool = True,\n) -&gt; None\n</code></pre> <p>Register the given class and its child classes.</p> <p>This function registers all the child classes including the child classes of the child classes, etc.</p> <p>Parameters:</p> Name Type Description Default <code>factory_cls</code> <code>AbstractFactory | type</code> <p>The factory class. The child classes will be registered to this class.</p> required <code>cls</code> <code>type</code> <p>The class to register along with its child classes.</p> required <code>ignore_abstract_class</code> <code>bool</code> <p>Indicate if the abstract classes should be ignored or not. By default, the abstract classes are not registered because they cannot be instantiated.</p> <code>True</code> <p>Raises:</p> Type Description <code>AbstractFactoryTypeError</code> <p>if the factory class does not implement the <code>AbstractFactory</code> metaclass.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from objectory.abstract_factory import AbstractFactory, register_child_classes\n&gt;&gt;&gt; class BaseClass(metaclass=AbstractFactory):\n...     pass\n...\n&gt;&gt;&gt; register_child_classes(BaseClass, dict)\n</code></pre>"},{"location":"refs/registry/","title":"Registry","text":""},{"location":"refs/registry/#objectory.registry","title":"objectory.registry","text":"<p>Implement the registry class.</p>"},{"location":"refs/registry/#objectory.registry.Registry","title":"objectory.registry.Registry","text":"<p>Implement the registry class.</p> <p>This class can be used to register some objects and instantiate an object from its configuration.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from objectory import Registry\n&gt;&gt;&gt; from collections import Counter\n&gt;&gt;&gt; registry = Registry()\n&gt;&gt;&gt; registry.register_object(Counter)\n&gt;&gt;&gt; registry.factory(\"collections.Counter\")\nCounter()\n</code></pre>"},{"location":"refs/registry/#objectory.registry.Registry.__getattr__","title":"objectory.registry.Registry.__getattr__","text":"<pre><code>__getattr__(key: str) -&gt; Registry | type\n</code></pre> <p>Get the registry associated to a key.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The key.</p> required <p>Returns:</p> Type Description <code>Registry | type</code> <p>The registry associated to the key.</p> <p>Raises:</p> Type Description <code>InvalidAttributeRegistryError</code> <p>if the associated attribute is not a registry.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from collections import Counter\n&gt;&gt;&gt; registry = Registry()\n&gt;&gt;&gt; registry.other.register_object(Counter)\n</code></pre>"},{"location":"refs/registry/#objectory.registry.Registry.__len__","title":"objectory.registry.Registry.__len__","text":"<pre><code>__len__() -&gt; int\n</code></pre> <p>Return the number of registered objects.</p> <p>Returns:</p> Type Description <code>int</code> <p>The number of registered objects.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from objectory import Registry\n&gt;&gt;&gt; from collections import Counter\n&gt;&gt;&gt; registry = Registry()\n&gt;&gt;&gt; registry.register_object(Counter)\n&gt;&gt;&gt; len(registry)\n1\n</code></pre>"},{"location":"refs/registry/#objectory.registry.Registry.clear","title":"objectory.registry.Registry.clear","text":"<pre><code>clear(nested: bool = False) -&gt; None\n</code></pre> <p>Clear the registry.</p> <p>This functions removes all the registered objects in the registry.</p> <p>Parameters:</p> Name Type Description Default <code>nested</code> <code>bool</code> <p>Indicates if the sub-registries should be cleared or not.</p> <code>False</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from objectory import Registry\n&gt;&gt;&gt; registry = Registry()\n&gt;&gt;&gt; # Clear the main registry.\n&gt;&gt;&gt; registry.clear()\n&gt;&gt;&gt; # Clear only the sub-registry other.\n&gt;&gt;&gt; registry.other.clear()\n&gt;&gt;&gt; # Clear the main registry and its sub-registries.\n&gt;&gt;&gt; registry.clear(nested=True)\n</code></pre>"},{"location":"refs/registry/#objectory.registry.Registry.clear_filters","title":"objectory.registry.Registry.clear_filters","text":"<pre><code>clear_filters(nested: bool = False) -&gt; None\n</code></pre> <p>Clear all the filters of the registry.</p> <p>Parameters:</p> Name Type Description Default <code>nested</code> <code>bool</code> <p>Indicates if the filters of all the sub-registries should be cleared or not.</p> <code>False</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from objectory import Registry\n&gt;&gt;&gt; registry = Registry()\n&gt;&gt;&gt; # Clear the filters of the main registry.\n&gt;&gt;&gt; registry.clear_filters()\n&gt;&gt;&gt; # Clear the filters of the sub-registry other.\n&gt;&gt;&gt; registry.other.clear_filters()\n&gt;&gt;&gt; # Clear the filters of the main registry and all its sub-registries.\n&gt;&gt;&gt; registry.clear_filters(nested=True)\n</code></pre>"},{"location":"refs/registry/#objectory.registry.Registry.factory","title":"objectory.registry.Registry.factory","text":"<pre><code>factory(\n    _target_: str,\n    *args: Any,\n    _init_: str = \"__init__\",\n    **kwargs: Any\n) -&gt; Any\n</code></pre> <p>Instantiate dynamically an object given its configuration.</p> <p>This method creates an instance of a registered class or calls a registered function. The target can be specified using either the short name or the fully qualified name. If the target is not yet registered, it will attempt to import and register it automatically.</p> <p>Parameters:</p> Name Type Description Default <code>_target_ </code> <p>The name of the object (class or function) to instantiate. It can be the class name or the full class name. Supports name resolution for registered objects.</p> required <code>*args</code> <code>Any</code> <p>Positional arguments to pass to the class constructor or function.</p> <code>()</code> <code>_init_</code> <code>str</code> <p>The function or method to use to create the object. If <code>\"__init__\"</code> (default), the object is created by calling the constructor. Can also be <code>\"__new__\"</code> or the name of a class method.</p> <code>'__init__'</code> <code>**kwargs</code> <code>Any</code> <p>Keyword arguments to pass to the class constructor or function.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Any</code> <p>The instantiated object with the given parameters.</p> <p>Raises:</p> Type Description <code>AbstractClassAbstractFactoryError</code> <p>when an abstract class is instantiated.</p> <code>UnregisteredClassAbstractFactoryError</code> <p>if the target name is not found.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from objectory import Registry\n&gt;&gt;&gt; registry = Registry()\n&gt;&gt;&gt; @registry.register()\n... class MyClass:\n...     pass\n...\n&gt;&gt;&gt; registry.factory(\"MyClass\")\n&lt;....MyClass object at 0x...&gt;\n</code></pre>"},{"location":"refs/registry/#objectory.registry.Registry.register","title":"objectory.registry.Registry.register","text":"<pre><code>register(name: str | None = None) -&gt; Callable\n</code></pre> <p>Define a decorator to add a class or a function to the registry.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str | None</code> <p>The name to use to register the object. If <code>None</code>, the full name of the object is used as name.</p> <code>None</code> <p>Returns:</p> Type Description <code>Callable</code> <p>The decorated object.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from objectory import Registry\n&gt;&gt;&gt; registry = Registry()\n&gt;&gt;&gt; @registry.register()\n... class ClassToRegister:\n...     pass\n...\n&gt;&gt;&gt; registry.registered_names()\n{'....ClassToRegister'}\n&gt;&gt;&gt; @registry.register()\n... def function_to_register(*args, **kwargs):\n...     pass\n...\n&gt;&gt;&gt; registry.registered_names()\n{...}\n</code></pre>"},{"location":"refs/registry/#objectory.registry.Registry.register_child_classes","title":"objectory.registry.Registry.register_child_classes","text":"<pre><code>register_child_classes(\n    cls: type, ignore_abstract_class: bool = True\n) -&gt; None\n</code></pre> <p>Register a given class and its child classes.</p> <p>This function registers all the child classes including the child classes of the child classes, etc. If you use this function, you cannot choose the names used to register the objects. It will use the fully qualified name of each object.</p> <p>Parameters:</p> Name Type Description Default <code>cls</code> <code>type</code> <p>The class to register along with its child classes.</p> required <code>ignore_abstract_class</code> <code>bool</code> <p>Indicate if the abstract classes should be ignored or not. By default, the abstract classes are not registered because they cannot be instantiated.</p> <code>True</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from objectory import Registry\n&gt;&gt;&gt; registry = Registry()\n&gt;&gt;&gt; registry.register_child_classes(dict)\n&gt;&gt;&gt; registry.registered_names()\n{...}\n</code></pre>"},{"location":"refs/registry/#objectory.registry.Registry.register_object","title":"objectory.registry.Registry.register_object","text":"<pre><code>register_object(\n    obj: type | Callable, name: str | None = None\n) -&gt; None\n</code></pre> <p>Register an object.</p> <p>This method adds a class or function to the registry, making it available for instantiation through the factory method. You can optionally specify a custom name for the object; otherwise, its fully qualified name will be used. If a class filter is set, the object must be a subclass of the filter class.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>type | Callable</code> <p>The object to register. The object must be a class or a function (not a lambda function).</p> required <code>name</code> <code>str | None</code> <p>The name to use to register the object. If <code>None</code>, the fully qualified name of the object is used. Cannot conflict with sub-registry names.</p> <code>None</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from objectory import Registry\n&gt;&gt;&gt; registry = Registry()\n&gt;&gt;&gt; class ClassToRegister:\n...     pass\n...\n&gt;&gt;&gt; registry.register_object(ClassToRegister)\n&gt;&gt;&gt; registry.registered_names()\n{'....ClassToRegister'}\n&gt;&gt;&gt; def function_to_register(*args, **kwargs):\n...     pass\n...\n&gt;&gt;&gt; registry.register_object(function_to_register)\n&gt;&gt;&gt; registry.registered_names()\n{...}\n</code></pre>"},{"location":"refs/registry/#objectory.registry.Registry.registered_names","title":"objectory.registry.Registry.registered_names","text":"<pre><code>registered_names(include_registry: bool = True) -&gt; set[str]\n</code></pre> <p>Get the names of all the registered objects.</p> <p>Parameters:</p> Name Type Description Default <code>include_registry</code> <code>bool</code> <p>Indicates if the other (sub-)registries should be included in the set. By default, the other (sub-)registries are included.</p> <code>True</code> <p>Returns:</p> Type Description <code>set[str]</code> <p>The names of the registered objects.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from objectory import Registry\n&gt;&gt;&gt; registry = Registry()\n&gt;&gt;&gt; registry.registered_names()\n&gt;&gt;&gt; # Show name of all the registered objects except the sub-registries.\n&gt;&gt;&gt; registry.registered_names(include_registry=False)\n</code></pre>"},{"location":"refs/registry/#objectory.registry.Registry.set_class_filter","title":"objectory.registry.Registry.set_class_filter","text":"<pre><code>set_class_filter(cls: type | None) -&gt; None\n</code></pre> <p>Set the class filter so only the child classes of this class can be registered.</p> <p>If you set this filter, you cannot register functions. To unset this filter, you can use <code>set_class_filter(None)</code>.</p> <p>Parameters:</p> Name Type Description Default <code>cls</code> <code>type | None</code> <p>The class to use as filter. Only the child classes of this class can be registered.</p> required <p>Raises:</p> Type Description <code>TypeError</code> <p>if the input is not a class or <code>None</code>.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from collections import Counter, OrderedDict\n&gt;&gt;&gt; from objectory import Registry\n&gt;&gt;&gt; registry = Registry()\n&gt;&gt;&gt; registry.mapping.set_class_filter(dict)\n&gt;&gt;&gt; registry.mapping.register_object(OrderedDict)\n&gt;&gt;&gt; registry.mapping.registered_names()\n{'collections.OrderedDict'}\n</code></pre>"},{"location":"refs/registry/#objectory.registry.Registry.unregister","title":"objectory.registry.Registry.unregister","text":"<pre><code>unregister(name: str) -&gt; None\n</code></pre> <p>Remove a registered object.</p> <p>This method removes a class or function from the registry. The object will no longer be available for instantiation through the factory method.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the object to remove. Can be either the short name or the fully qualified name. This function uses the name resolution mechanism to find the full name if only the short name is given.</p> required <p>Raises:</p> Type Description <code>UnregisteredObjectFactoryError</code> <p>if the name does not exist in the registry.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from objectory import Registry\n&gt;&gt;&gt; from collections import Counter\n&gt;&gt;&gt; registry = Registry()\n&gt;&gt;&gt; registry.register_object(Counter)\n&gt;&gt;&gt; registry.unregister(\"collections.Counter\")\n</code></pre>"},{"location":"refs/utils/","title":"Utils","text":""},{"location":"refs/utils/#objectory.utils","title":"objectory.utils","text":"<p>Contain some utility functions or helpers.</p>"},{"location":"refs/utils/#objectory.utils.all_child_classes","title":"objectory.utils.all_child_classes","text":"<pre><code>all_child_classes(cls: type) -&gt; set[type]\n</code></pre> <p>Get all the child classes (or subclasses) of a given class.</p> <p>Based on: https://stackoverflow.com/a/3862957</p> <p>Parameters:</p> Name Type Description Default <code>cls</code> <code>type</code> <p>The class whose child classes are to be retrieved.</p> required <p>Returns:</p> Type Description <code>set[type]</code> <p>The set of all the child classes of the given class.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from objectory.utils import all_child_classes\n&gt;&gt;&gt; class Foo:\n...     pass\n...\n&gt;&gt;&gt; all_child_classes(Foo)\nset()\n&gt;&gt;&gt; class Bar(Foo):\n...     pass\n...\n&gt;&gt;&gt; all_child_classes(Foo)\n{&lt;class '....Bar'&gt;}\n</code></pre>"},{"location":"refs/utils/#objectory.utils.get_fully_qualified_name","title":"objectory.utils.get_fully_qualified_name","text":"<pre><code>get_fully_qualified_name(obj: Any) -&gt; str\n</code></pre> <p>Return the fully qualified name of a Python object.</p> <p>This function computes the fully qualified name (module path + object name) for various Python objects including functions, classes, methods, and instances. For instances, it returns the fully qualified name of their class. The format is \"module.path.ObjectName\" (e.g., \"collections.Counter\").</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>Any</code> <p>The object whose fully qualified name is to be computed. Can be a class, function, method, or instance.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The fully qualified name.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from objectory.utils import get_fully_qualified_name\n&gt;&gt;&gt; import collections\n&gt;&gt;&gt; get_fully_qualified_name(collections.Counter)\n'collections.Counter'\n&gt;&gt;&gt; class MyClass:\n...     pass\n...\n&gt;&gt;&gt; get_fully_qualified_name(MyClass)\n'....MyClass'\n&gt;&gt;&gt; get_fully_qualified_name(map)\n'builtins.map'\n</code></pre>"},{"location":"refs/utils/#objectory.utils.import_object","title":"objectory.utils.import_object","text":"<pre><code>import_object(object_path: str) -&gt; Any\n</code></pre> <p>Import an object given its path.</p> <p>This function dynamically imports a class, function, or other Python object using its fully qualified name. The object path should have the structure <code>module_path.object_name</code> (e.g., \"collections.Counter\" or \"math.isclose\"). If the path is invalid or the object cannot be imported, the function returns <code>None</code> instead of raising an exception.</p> <p>Parameters:</p> Name Type Description Default <code>object_path</code> <code>str</code> <p>The fully qualified path of the object to import. Must be a string in the format \"module.path.ObjectName\".</p> required <p>Returns:</p> Type Description <code>Any</code> <p>The object if the import was successful otherwise <code>None</code>.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from objectory.utils import import_object\n&gt;&gt;&gt; obj = import_object(\"collections.Counter\")\n&gt;&gt;&gt; obj()\nCounter()\n&gt;&gt;&gt; fn = import_object(\"math.isclose\")\n&gt;&gt;&gt; fn(1, 1)\nTrue\n</code></pre>"},{"location":"refs/utils/#objectory.utils.instantiate_object","title":"objectory.utils.instantiate_object","text":"<pre><code>instantiate_object(\n    obj: Callable | type,\n    *args: Any,\n    _init_: str = \"__init__\",\n    **kwargs: Any\n) -&gt; Any\n</code></pre> <p>Instantiate dynamically an object from its configuration.</p> <p>This function creates an instance of a class or calls a function with the provided arguments. For classes, it supports different instantiation methods (constructor, new, or class methods). For functions, it simply calls them with the given arguments.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>Callable | type</code> <p>The class to instantiate or the function to call. Must be a class or function object.</p> required <code>*args</code> <code>Any</code> <p>Positional arguments to pass to the class constructor or function.</p> <code>()</code> <code>_init_</code> <code>str</code> <p>The function or method to use to create the object. This parameter is ignored if <code>obj</code> is a function. For classes, if <code>\"__init__\"</code> (default), the object is created by calling the constructor. Can also be <code>\"__new__\"</code> or the name of a class method.</p> <code>'__init__'</code> <code>**kwargs</code> <code>Any</code> <p>Keyword arguments to pass to the class constructor or function.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Any</code> <p>The instantiated object if <code>obj</code> is a class name, otherwise the returned value of the function.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>if <code>obj</code> is not a class or a function.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from collections import Counter\n&gt;&gt;&gt; from objectory.utils import instantiate_object\n&gt;&gt;&gt; instantiate_object(Counter, [1, 2, 1])\nCounter({1: 2, 2: 1})\n&gt;&gt;&gt; instantiate_object(list, [1, 2, 1])\n[1, 2, 1]\n</code></pre>"},{"location":"refs/utils/#objectory.utils.is_lambda_function","title":"objectory.utils.is_lambda_function","text":"<pre><code>is_lambda_function(obj: Any) -&gt; bool\n</code></pre> <p>Indicate if the object is a lambda function or not.</p> <p>This function checks whether a given object is a lambda function by examining its type and name. Lambda functions are not allowed in factories because they cannot be reliably serialized or referenced by name. Adapted from https://stackoverflow.com/a/23852434</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>Any</code> <p>The object to check. Can be any Python object.</p> required <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the input is a lambda function, otherwise <code>False</code></p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from objectory.utils import is_lambda_function\n&gt;&gt;&gt; is_lambda_function(lambda value: value + 1)\nTrue\n&gt;&gt;&gt; def my_function(value: int) -&gt; int:\n...     return value + 1\n...\n&gt;&gt;&gt; is_lambda_function(my_function)\nFalse\n&gt;&gt;&gt; is_lambda_function(1)\nFalse\n</code></pre>"},{"location":"refs/utils/#objectory.utils.is_object_config","title":"objectory.utils.is_object_config","text":"<pre><code>is_object_config(config: dict, cls: type) -&gt; bool\n</code></pre> <p>Indicate if the input configuration is a configuration for a given class.</p> <p>This function only checks if the value of the key  <code>_target_</code> is valid. It does not check the other values. If <code>_target_</code> indicates a function, the returned type hint is used to check the class.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>dict</code> <p>The configuration to check.</p> required <code>cls</code> <code>type</code> <p>The object class.</p> required <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the input configuration is a configuration for the given class.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from objectory.utils import is_object_config\n&gt;&gt;&gt; from collections import Counter\n&gt;&gt;&gt; is_object_config({\"_target_\": \"collections.Counter\", \"iterable\": [1, 2, 1, 3]}, Counter)\nTrue\n</code></pre>"},{"location":"refs/utils/#objectory.utils.resolve_name","title":"objectory.utils.resolve_name","text":"<pre><code>resolve_name(\n    name: str,\n    object_names: set[str],\n    allow_import: bool = True,\n) -&gt; str | None\n</code></pre> <p>Find a match of the query name in the set of object names.</p> <p>This function implements a name resolution mechanism that allows short names (e.g., \"MyClass\") to be resolved to fully qualified names (e.g., \"mymodule.MyClass\"). The resolution is successful only if there is exactly one object name that matches the query. If the name is a fully qualified name not in the set, it will attempt to import the module and return the resolved name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The query name to use to find a match in the set of object names. Can be a short name or fully qualified name.</p> required <code>object_names</code> <code>set[str]</code> <p>The set of registered object names to search through.</p> required <code>allow_import</code> <code>bool</code> <p>If <code>True</code> (default), the function will attempt to import the module if the name appears to be a fully qualified name not in the set.</p> <code>True</code> <p>Returns:</p> Type Description <code>str | None</code> <p>The resolved name if the resolution was successful, otherwise <code>None</code></p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from objectory.utils import resolve_name\n&gt;&gt;&gt; resolve_name(\"OrderedDict\", {\"collections.OrderedDict\", \"collections.Counter\"})\ncollections.OrderedDict\n&gt;&gt;&gt; resolve_name(\"objectory.utils.resolve_name\", {\"math.isclose\"})\n'objectory.utils.name_resolution.resolve_name'\n&gt;&gt;&gt; resolve_name(\"OrderedDict\", {\"collections.Counter\", \"math.isclose\"})\nNone\n</code></pre>"}]}