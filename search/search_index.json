{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#overview","title":"Overview","text":"<p>A Python library for general purpose object factories. In particular, it focuses on dynamic object factory implementations where objects can be registered dynamically without changing the code of the factory. An object factory can be used to instantiate an object from its configuration. The current implementation contains both abstract factory and registry approaches.</p> <p>factory</p> <pre><code>from objectory import factory\n\n\nclass MyClass:\n    pass\n\n\nobj = factory(\"MyClass\")\nprint(obj)\n</code></pre> <p>abstract factory</p> <pre><code>from objectory import AbstractFactory\n\n\nclass BaseClass(metaclass=AbstractFactory):\n    pass\n\n\nclass MyClass(BaseClass):\n    pass\n\n\nobj = BaseClass.factory(\"MyClass\")\nprint(obj)\n</code></pre> <p>Output:</p> <pre><code>&lt;__main__.MyClass object at 0x...&gt;\n</code></pre> <p>registry</p> <pre><code>from objectory import Registry\n\nregistry = Registry()\n\n\n@registry.register()\nclass MyClass:\n    pass\n\n\nobj = registry.factory(\"MyClass\")\nprint(obj)\n</code></pre> <pre><code>&lt;__main__.MyClass object at 0x...&gt;\n</code></pre>"},{"location":"#api-stability","title":"API stability","text":"<p> While <code>objectory</code> is in development stage, no API is guaranteed to be stable from one release to the next. In fact, it is very likely that the API will change multiple times before a stable 1.0.0 release. In practice, this means that upgrading <code>objectory</code> to a new version will possibly break any code that was using the old version of <code>objectory</code>.</p>"},{"location":"#license","title":"License","text":"<p><code>objectory</code> is licensed under BSD 3-Clause \"New\" or \"Revised\" license available in LICENSE file.</p>"},{"location":"abstract_factory/","title":"Abstract Factory","text":"<p>This page presents the <code>AbstractFactory</code> metaclass which implement an abstract factory design pattern. The abstract factory is a creational design pattern that lets you produce families of related objects without specifying their concrete classes. This design pattern is also known as \"Factory of Factories\" because it is a \"super-factory\" which creates other factories. This metaclass proposes an implementation for creating a factory of related objects without explicitly specifying their classes. Each generated factory can instantiate the objects as per the Factory pattern.</p>"},{"location":"abstract_factory/#create-a-factory","title":"Create a factory","text":"<p>The <code>AbstractFactory</code> metaclass is not a factory, but it contains the blueprint on how to build a factory. To create a factory, you will define a base class. This class is used to register the other classes but also to define the common interface of the factory. In the following of the documentation, we will call this class the base factory class. The example below shows the minimal implementation of a base class:</p> <pre><code>from objectory import AbstractFactory\n\n\nclass BaseClass(metaclass=AbstractFactory):\n    pass\n</code></pre> <p>The base class should inherit the <code>AbstractFactory</code> metaclass. This metaclass will implement the factory mechanism to the base class. The base class can implement functions and attributes like a regular python class. It can also be an abstract class or not.</p>"},{"location":"abstract_factory/#register-an-object","title":"Register an object","text":"<p>This section explains the basics on how to register an object to a factory. It is possible to register a function. This section assumes you already created a factory as explained above. There are two approaches to register an object to the factory:</p> <ul> <li>by using the inheritance (only for class)</li> <li>by using the <code>register_object</code> function (both class and function)</li> </ul>"},{"location":"abstract_factory/#inheritance","title":"Inheritance","text":"<p>The recommended approach to register a class to the factory is to use the inheritance. Every time that you create a new child class of the base factory class, the child class is automatically registered to the factory. For example, you can define the <code>Child1Class</code> class with the following implementation:</p> <pre><code>from objectory import AbstractFactory\n\n\nclass BaseClass(metaclass=AbstractFactory):\n    pass\n\n\nclass Child1Class(BaseClass):\n    pass\n</code></pre> <p>When the <code>Child1Class</code> class is created, it is automatically added to the <code>BaseClass</code> factory. The developer does not have to write any additional line to register the class. It is possible to define more complex child classes with a constructor or any functions/attributes. For example, you can define the <code>Child2Class</code> class with the following implementation:</p> <pre><code>class Child2Class(BaseClass):\n    def __init__(self, dim: int):\n        self.dim = dim\n</code></pre> <p>Similarly, any grand child class of the base factory class is automatically registered to the factory. In the following example, the <code>Child3Class</code> class which inherits from <code>Child1Class</code> class will be added to the <code>BaseClass</code> factory:</p> <pre><code>class Child3Class(Child1Class):\n    pass\n</code></pre>"},{"location":"abstract_factory/#register_object-function","title":"<code>register_object</code> function","text":"<p>The inheritance approach works when it is possible to modify the source code of the classes because each registered need to inherit from the base factory class. However, it is not possible to do that in particular when the code depends on a third party library. To overcome this limitation, it is possible to use the <code>register_object</code> function to manually register some classes that are defined outside the project.</p> <p>Let's take the example of PyTorch. PyTorch is an open source machine learning framework. To define a machine learning model in PyTorch, you can implement a new class that inherits from the <code>torch.nn.Module</code> class. PyTorch also provides many module implementations. If you want to build a factory that includes both your module implementations and the PyTorch ones, you can do it by using the inheritance and the <code>register_object</code> function. First, you need to define the base factory class:</p> <pre><code>import torch\nfrom objectory import AbstractFactory\n\n\nclass BaseModule(torch.nn.Module, metaclass=AbstractFactory):\n    pass\n\n\nclass MyModule1(BaseModule):\n    pass\n\n\nclass MyModule2(BaseModule):\n    pass\n</code></pre> <p>Then you can register some modules implemented in PyTorch. For example if you want to register the class <code>torch.nn.Linear</code> to the factory of <code>BaseModule</code>, you can write the following lines:</p> <pre><code>import torch\n\nBaseModule.register_object(torch.nn.Linear)\n</code></pre> <p>The <code>register_object</code> function can be used to register a class but also a function. To be consistent with the factory idea, you should only register functions that returns an object that is compatible with the common interface of the factory. Note that no warning will be raised if you do not follow this rule, but it will be your responsibility to manage this situation. Please keep in mind that with power comes responsibility. The following example shows how to register a function:</p> <pre><code>import torch\n\n\ndef my_nodule(input_size: int, output_size: int) -&gt; torch.nn.Module:\n    return torch.nn.Sequential(\n        torch.nn.Linear(input_size, 32),\n        torch.nn.ReLU(),\n        torch.nn.Linear(32, output_size),\n    )\n\n\nBaseModule.register_object(my_nodule)\n</code></pre> <p>Another approach to register a function is to use the decorator <code>register</code>:</p> <pre><code>import torch\nfrom objectory import register\n\n\n@register(BaseModule)\ndef my_nodule(input_size: int, output_size: int) -&gt; torch.nn.Module:\n    return torch.nn.Sequential(\n        torch.nn.Linear(input_size, 32),\n        torch.nn.ReLU(),\n        torch.nn.Linear(32, output_size),\n    )\n</code></pre> <p>The argument of the decorator is the base factory class where the function will be registered.</p> <p> It is not possible to register a lambda function. Please use a regular python function instead. The registry will raise the exception <code>IncorrectObjectFactoryError</code> if you try to register a lambda function.</p>"},{"location":"abstract_factory/#registered-objects","title":"Registered objects","text":""},{"location":"abstract_factory/#inheritors","title":"Inheritors","text":"<p>Sometimes it is important to know what are the registered objects to the factory. You can see the list of the objects that are registered to the base class by using the attribute <code>inheritors</code>. This attribute contains the full name of the class as well as the class. If you print the value of <code>inheritors</code>,</p> <pre><code>print(BaseClass.inheritors)\n</code></pre> <p>Output:</p> <pre><code>{\n  \"my_package.base.BaseClass\": &lt;class \"my_package.base.BaseClass\"&gt;,\n  \"my_package.child1.Child1Class\": &lt;class \"my_package.child1.Child1Class\"&gt;,\n  \"my_package.child2.Child2Class\": &lt;class \"my_package.child2.Child2Class\"&gt;,\n  \"my_package.child3.Child3Class\": &lt;class \"my_package.child3.Child3Class\"&gt;\n}\n</code></pre> <p>This example assumes that the <code>BaseClass</code> is written in the file <code>my_package/base.py</code> and <code>Child&lt;X&gt;Class</code> is written in the file <code>my_package/child&lt;X&gt;.py</code>.</p> <p>Note that the base class and all its children classes have the attribute <code>inheritors</code> so you can check the registered objects with any of these classes:</p> <pre><code>print(Child1Class.inheritors)\nprint(Child2Class.inheritors)\n</code></pre> <p>Output:</p> <pre><code>{\n  \"my_package.base.BaseClass\": &lt;class \"my_package.base.BaseClass\"&gt;,\n  \"my_package.child1.Child1Class\": &lt;class \"my_package.child1.Child1Class\"&gt;,\n  \"my_package.child2.Child2Class\": &lt;class \"my_package.child2.Child2Class\"&gt;,\n  \"my_package.child3.Child3Class\": &lt;class \"my_package.child3.Child3Class\"&gt;\n}\n{\n  \"my_package.base.BaseClass\": &lt;class \"my_package.base.BaseClass\"&gt;,\n  \"my_package.child1.Child1Class\": &lt;class \"my_package.child1.Child1Class\"&gt;,\n  \"my_package.child2.Child2Class\": &lt;class \"my_package.child2.Child2Class\"&gt;,\n  \"my_package.child3.Child3Class\": &lt;class \"my_package.child3.Child3Class\"&gt;\n}\n</code></pre> <p>The key of each object is the full name of the object. If you register two objects with the same full class name (package name + module name + class name), only the last object will be registered. It is the responsibility of the user to manage the object name to avoid duplicate.</p> <p>If you have registered some functions, you should see them in the inheritors. For example if you have registered the function <code>my_nodule</code> in the <code>BaseModule</code>, you should see something like: <code>'my_package.nodule.my_nodule': &lt;function my_nodule at 0x...&gt;</code>.</p>"},{"location":"abstract_factory/#missing-objects","title":"Missing objects","text":"<p>To be added to the factory, an object has to be loaded at least one time. The objects are automatically registered when they are loaded the first time. An object which is never loaded will never be registered. If you do not see an object in the list of inheritors, it is probably because it was not loaded. First, verify that the object inherits from the base factory class or the <code>register</code> function is called. Then, check if the python module with the object is loaded at least one time.</p> <p>A solution to this problem is to write the child classes in the same python module that the base factory class. However, this solution is not always good or possible. When there is a lot of objects, it is usually better to write them in several python modules.</p> <p>Let's assume the following situation where each class is written in a different python module. The package should have the following structure:</p> <pre><code>my_package/\n    __init__.py\n    base.py\n    child1.py\n    child2.py\n</code></pre> <p>A solution is to import the child classes in the <code>__init__.py</code>. The file <code>__init__.py</code> should have the following lines</p> <pre><code>from my_package import child1\nfrom my_package import child2\n</code></pre> <p>Another solution is to use the import package tool.</p>"},{"location":"abstract_factory/#factory","title":"Factory","text":"<p>This section explains how to instantiate dynamically a class registered in a <code>AbstractFactory</code>. One of the operation done by the <code>AbstractFactory</code> metaclass is to add the <code>factory</code> function to the base factory class and all its child classes. This function can instantiate any registered class given its configuration. The signature of the<code>factory</code> function is:</p> <pre><code>def factory(cls, _target_: str, *args, _init_: str = \"__init__\", **kwargs): ...\n</code></pre> <p>where <code>*args</code> and <code>**kwargs</code> are the parameters of the object to instantiate. The input <code>_target_</code> is used to define the name of the object to instantiate and <code>_init_</code> indicates the function used to create the object. The following sections will explain the role of each parameter and how to use them.</p>"},{"location":"abstract_factory/#target-object","title":"Target object","text":"<p>One of the key features of the <code>factory</code> function is that you can specify the name of the object that you want to instantiate. The <code>_target_</code> input is used to define the name of the object to instantiate. For example if you want to create an  <code>Child1Class</code> object, you can write:</p> <pre><code>my_obj = BaseClass.factory(\"my_package.child1.Child1Class\")\n</code></pre> <p>When you instantiate an object, you can also specify the arguments. For example if you want to create a <code>Child2Class</code> object with 10 layers, you can write:</p> <pre><code>my_obj = BaseClass.factory(\"my_package.child2.Child2Class\", num_layers=10)\n</code></pre> <p>Sometimes it can be time consuming to write the full class name. If the class name is unique, you can instantiate the object by only specifying the class name. In the previous example, instead of the full class name (<code>my_package.child1.Child1Class</code>) you can specify only the class name (<code>Child1Class</code>):</p> <pre><code>my_obj = BaseClass.factory(\"Child1Class\")\n</code></pre> <p>The second approach is easier to use, but it forces each class name to be unique. Under the hood, the factory uses the name resolution mechanism to find the path where the class is. If the class name is not unique, the name resolution mechanism will not be able to instantiate the object because of the ambiguity. If several classes have the same name, you need to specify the full name to break the ambiguity.</p> <p>Let's imagine the case where there are two classes with the same name <code>Linear</code>.</p> <pre><code>import torch\n\n# Register the class Linear from PyTorch\nBaseModule.register_object(torch.nn.Linear)\n\n\n# Register another class Linear\nclass Linear(BaseModule):\n    pass\n</code></pre> <p>There is no problem to register to class with the same class name because their full class name are different (<code>torch.nn.modules.linear.Linear</code> vs <code>__main__.Linear</code>). Please read the name resolution mechanism documentation to learn why the real full name of <code>torch.nn.linear.Linear</code> is <code>torch.nn.modules.linear.Linear</code>. If you want to instantiate the <code>Linear</code> class from PyTorch, you will need to give the full class name:</p> <pre><code>my_obj = BaseModule.factory(\"torch.nn.Linear\", in_features=8, out_features=6)\n</code></pre> <p>If you want to instantiate the local <code>Linear</code> class, you will need to give the full class name:</p> <pre><code>my_obj = BaseModule.factory(\"__main__.Linear\", in_features=8, out_features=6)\n</code></pre> <p>If you only specify <code>Linear</code>, the factory does not know what class you want to instantiate and will raise an error.</p> <pre><code>my_obj = BaseModule.factory(\"Linear\", in_features=8, out_features=6)\n# Raise the error: factory.error.UnregisteredObjectFactoryError: Unable to create the object Linear.\n# Registered objects of BaseModule are {'__main__.Linear', 'torch.nn.modules.linear.Linear'}\n</code></pre> <p>If several classes have the same name, the only solution is to specify the full class name. Similarly to class, it is possible to specify the name of the function to call. For example if you want to call the <code>my_nodule</code> function previously defined, you can write:</p> <pre><code>net = BaseModule.factory(\"my_package.nodule.my_nodule\", input_size=4, output_size=12)\n</code></pre> <p>Finally, you can call the <code>factory</code> function with any class that inherits from the base factory class:</p> <pre><code>my_obj = BaseClass.factory(\"my_package.child1.Child1Class\")\n# or\nmy_obj = Child1Class.factory(\"my_package.child1.Child1Class\")\n# or\nmy_obj = Child2Class.factory(\"my_package.child1.Child1Class\")\n</code></pre>"},{"location":"abstract_factory/#initialization-function","title":"Initialization function","text":"<p>By default, the <code>factory</code> function calls the function <code>__init__</code> of a class to create an object. You can also create an object by using a class method. You can use the keyword to <code>_init_</code> to specify the function to use to create the object. The default value of this keyword is <code>\"__init__\"</code> so you do not need to change it if you call the default constructor. Note the initialization function input is only available for the classes. This input is ignored when you call a function to instantiate an object.</p> <p>Let's define a new class that has a class method to create an object:</p> <pre><code># file: my_package/child4.py\nclass Child4Class(BaseClass):\n    def __init__(self, dim: int):\n        self.dim = dim\n\n    @classmethod\n    def default(cls):\n        return cls(dim=256)\n</code></pre> <p>Then, you can create an <code>Child4Class</code> object with the default method with the following command:</p> <pre><code>my_obj = BaseClass.factory(\n    _target_=\"my_package.child4.Child4Class\",\n    _init_=\"default\",\n)\n</code></pre>"},{"location":"abstract_factory/#instantiate-an-unregistered-object","title":"Instantiate an unregistered object","text":"<p>The <code>AbstractFactory</code> metaclass provides some functionalities to dynamically instantiate an unregistered object. This feature is enabled by the name resolution mechanism. It is useful to instantiate an object which is not defined in a third party package. For example if you want to load the class <code>torch.nn.GRU</code>, you can use the following line:</p> <pre><code>net = BaseClass.factory(\"torch.nn.GRU\", input_size=4, hidden_size=12)\n</code></pre> <p>It is not necessary to register this class to instantiate it. If the <code>_target_</code> value is a module path, the <code>factory</code> function tries to import it. If the import is successful, the object is registered in the factory, so it is possible to reuse it later. This functionality is also useful when an object can be initialized by specifying several ways. Due to some imports in the <code>__init__.py</code> of some packages, some objects have several module paths. For example, a GRU object in PyTorch can be created by using the two approaches below:</p> <pre><code>net = BaseClass.factory(\"torch.nn.GRU\", input_size=4, hidden_size=12)\nnet = BaseClass.factory(\"torch.nn.modules.rnn.GRU\", input_size=4, hidden_size=12)\n</code></pre> <p>Please read the name resolution mechanism documentation to learn more about it.</p>"},{"location":"abstract_factory/#tools","title":"Tools","text":"<p>This section presents some useful tools for the <code>AbstractFactory</code> metaclass.</p>"},{"location":"abstract_factory/#register-all-the-child-classes","title":"Register all the child classes","text":"<p>In some cases, you may want to register a class and all its child classes. Instead of doing manually, you can use the function <code>register_child_classes</code>. This function will automatically register the given class and all its child classes. It will find all the child classes and will add them to the registry. It finds the child classes recursively, so it will also find the child classes of the child classes.</p> <p>Let's imagine you have the following classes, and you want to register them to the base class factory <code>BaseClass</code>:</p> <pre><code># file: my_package/my_module.py\nfrom objectory.abstract_factory import register_child_classes\n\n\nclass Foo:\n    pass\n\n\nclass Bar(Foo):\n    pass\n\n\nclass Baz(Foo):\n    pass\n\n\nclass Bing(Bar):\n    pass\n\n\nregister_child_classes(BaseClass, Foo)\nprint(BaseClass.inheritors)\n</code></pre> <p>Output:</p> <pre><code>{\n  'my_package.my_module.Foo',\n  'my_package.my_module.Baz',\n  'my_package.my_module.Bing',\n  'my_package.my_module.Bar'\n}\n</code></pre> <p>By default, the function <code>register_child_classes</code> ignores all the abstract classes because you cannot instantiate them. If you want to also register the abstract classes, you can use the argument <code>ignore_abstract_class=False</code>. The following example shows how to register all the <code>torch.nn.Module</code> including the abstract classes.</p> <pre><code>import torch\nfrom objectory.abstract_factory import register_child_classes\n\nregister_child_classes(BaseClass, torch.nn.Module, ignore_abstract_class=False)\n</code></pre>"},{"location":"abstract_factory/#error-messages","title":"Error messages","text":"<p>This section lists some of the most frequent error messages and explain how to fix the error. If you try to instantiate a class that is not registered (e.g. <code>Child3Class</code>), you will see the following error message:</p> <pre><code>objectory.abstract_factory.UnregisteredClassAbstractFactoryError: Unable to create\nthe class Child3Class. Verify that the class was added to the __init__.py file of its module.\nRegistered child classes of BaseClass are [\"child1class\", \"child2class\"]\n</code></pre> <p>The error shows the list of classes that are registered (<code>[\"my_package.base.BaseClass\", \"my_package.child1.Child1Class\", \"my_package.child2.Child2Class\"]</code> in this example). If your class does not appear in that list, it is probably because your class was never imported and registered. Keep in mind that each class has to be loaded at least once to be registered. The error <code>AbstractClassAbstractFactoryError</code> will be raised if you try to instantiate an abstract class because an abstract class cannot be instantiated.</p>"},{"location":"abstract_factory/#limitations","title":"Limitations","text":"<p>The  <code>AbstractFactory</code> metaclass adds some attributes and methods to the classes. To avoid potential conflicts with the other classes, all the non-public attributes and functions starts with <code>_abstractfactory_****</code> where <code>****</code> is the name of the attribute or the function. As presented above, you cannot define the following methods:</p> <ul> <li><code>inheritors</code></li> <li><code>factory</code></li> <li><code>register_object</code></li> <li><code>unregister</code></li> </ul>"},{"location":"get_started/","title":"Get Started","text":"<p>It is highly recommended to install in a virtual environment to keep your system in order.</p>"},{"location":"get_started/#installing-with-pip-recommended","title":"Installing with <code>pip</code> (recommended)","text":"<p>The following command installs the latest version of the library:</p> <pre><code>pip install objectory\n</code></pre>"},{"location":"get_started/#installing-from-source","title":"Installing from source","text":"<p>To install <code>objectory</code> from source, you can follow the steps below. First, you will need to install <code>poetry</code>. <code>poetry</code> is used to manage and install the dependencies. If <code>poetry</code> is already installed on your machine, you can skip this step. There are several ways to install <code>poetry</code> so you can use the one that you prefer. You can check the <code>poetry</code> installation by running the following command:</p> <pre><code>poetry --version\n</code></pre> <p>Then, you can clone the git repository:</p> <pre><code>git clone git@github.com:durandtibo/objectory.git\n</code></pre> <p>It is recommended to create a Python 3.8+ virtual environment. This step is optional so you can skip it. To create a virtual environment, you can use the following command:</p> <pre><code>make conda\n</code></pre> <p>It automatically creates a conda virtual environment. When the virtual environment is created, you can activate it with the following command:</p> <pre><code>conda activate objectory\n</code></pre> <p>This example uses <code>conda</code> to create a virtual environment, but you can use other tools or configurations. Then, you should install the required package to use <code>objectory</code> with the following command:</p> <pre><code>make install\n</code></pre> <p>This command will install all the required packages. You can also use this command to update the required packages. This command will check if there is a more recent package available and will install it. Finally, you can test the installation with the following command:</p> <pre><code>make unit-test-cov\n</code></pre>"},{"location":"name_resolution/","title":"Name Resolution Mechanism","text":"<p> Before to read this page, it is recommended to know how an object factory works. This page introduces the name resolution mechanism (NRM) which is used to find the real full name of the object that you want to load dynamically.</p>"},{"location":"name_resolution/#motivation","title":"Motivation","text":"<p>This section explains why the name resolution mechanism is important. To instantiate dynamically an object with an object factory, you need to specify the name of the object. Then, the object factory will look at its internal registry to find where is the object associated to the name that you gave. A problem happens when there are several ways to instantiate an object.</p> <p>Let's take the example of PyTorch \u2013note that the motivation is not specific to PyTorch and you can find similar situations in other libraries. PyTorch is an open source machine learning framework that accelerates the path from research prototyping to production deployment. In particular, let's look at the <code>torch.nn.Linear</code> class. According to the documentation, you can use this class in your code by writing something like:</p> <pre><code>from torch.nn import Linear\n</code></pre> <p>It will work but if you print the class <code>Linear</code>, you will see that the real path to it is not <code>torch.nn.Linear</code>. The real path of the class <code>Linear</code> class is:</p> <pre><code>torch.nn.modules.linear.Linear\n</code></pre> <p>Another way to import the class <code>Linear</code> is to write:</p> <pre><code>from torch.nn.modules.linear import Linear\n</code></pre> <p>So there are at least two ways to import the class <code>Linear</code>:</p> <ul> <li><code>from torch.nn import Linear</code></li> <li><code>from torch.nn.modules.linear import Linear</code></li> </ul> <p>Both approaches will give the same result. Which one should you use? </p> <p>Choosing one approach is probably not a good idea because it will force all the users to use the same approach which can be challenging in practice. A solution is to use a name resolution mechanism which will allow using several approaches to instantiate an object. By default, the <code>objectory</code> library uses the real full name to register an object. Each object is registered with its real full name, so in the PyTorch example, the class <code>Linear</code> is registered with the name <code>torch.nn.modules.linear.Linear</code>.</p> <p>The factory should understand that you can use <code>torch.nn.modules.linear.Linear</code> or <code>torch.nn.Linear</code> to instantiate the class <code>Linear</code>. If you give <code>torch.nn.Linear</code>, the name resolution mechanism should transform it in <code>torch.nn.modules.linear.Linear</code>.</p> <p>For the PyTorch library, the development team recommend to use <code>torch.nn.Linear</code> instead of <code>torch.nn.modules.linear.Linear</code> because it will make your code more robust to some changes in the package <code>torch.nn</code>. The name resolution mechanism will allow you to do that because you do not have to give the real full name of the object. Internally, the factory uses <code>torch.nn.modules.linear.Linear</code> and it connects the name <code>torch.nn.Linear</code> to <code>torch.nn.modules.linear.Linear</code> so specifying <code>torch.nn.Linear</code> is equivalent to write <code>torch.nn.modules.linear.Linear</code>.</p> <p>Another advantage of the name resolution mechanism is that you can specify only the object (class or function) name. Writing the full name of each object can be time-consuming. The advantage of writing the full name is that there is no ambiguity of the object that you want to instantiate if there are several objects with the same name. However, it is possible to use the information about the registered objects in the factory to find the object to use. For example if you want to instantiate an object of class <code>X</code>, you can look at how many objects with name <code>X</code> are registered in the factory. The name resolution mechanism will work if there is a single match i.e. there is a single registered object with the name <code>X</code>. It will not work if there are several matches because the factory does not know which object to choose. In that case you will have to use the full name of the object to break the ambiguity.</p> <p>If we continue with the previous example, you can use the query <code>Linear</code> to instantiate the class if there is no other object with that name in the factory. The name resolution mechanism will explore the names registered in the factory and will find it matches with <code>torch.nn.modules.linear.Linear</code>. It will associate <code>Linear</code> to <code>torch.nn.modules.linear.Linear</code>.</p>"},{"location":"name_resolution/#how-to-use-name-resolution-mechanism","title":"How to use name resolution mechanism","text":"<p>It is quite easy to use the name resolution mechanism, and it can be used outside the object factories. The first input is the query name, and the second input is the set of possible object names. In the object factory implementations, it is the set of registered object names. For the following example, let's assume the set of possible object names is: <code>{'torch.nn.modules.linear.Linear', 'my_package.MyClass'}</code>. The name resolution mechanism will try to find the query name in the set of possible object names. Let's assume that the query name is <code>'Linear'</code>. To use the name resolution mechanism, you can write the following code:</p> <pre><code>from objectory.utils import resolve_name\n\nprint(resolve_name(\"Linear\", {\"torch.nn.modules.linear.Linear\", \"my_package.MyClass\"}))\n</code></pre> <p>Output:</p> <pre><code>torch.nn.modules.linear.Linear\n</code></pre> <p>In this example, the resolved name is <code>'torch.nn.modules.linear.Linear'</code> because there is a single object with the name <code>Linear</code> in the set. Please read the next section to learn how the name resolution is done. The name resolution mechanism returns <code>None</code> if it cannot find the name.</p>"},{"location":"name_resolution/#how-does-the-name-resolution-mechanism-work","title":"How does the name resolution mechanism work?","text":"<p>The name resolution mechanism works in several steps. The inputs are a query name, and a set of object names. Then, the name resolution mechanism will try to find the full name of the object by using the following sequential process:</p> <ul> <li>Step 1. The first step looks at if the query name is in the set of object names.   If yes, it returns the query name because it can be directly used to instantiate the object.   If no, it goes to the second step.</li> <li>Step 2. The second step looks at the potential matches to the query name.   If there is a single match, it returns the matched object name because it can be directly used to   instantiate the object.   If there are multiple matches, it goes to the third step.   This step is useful to manage the case where the user only specifies the object name.   For example, it will work if the query name is <code>Linear</code> and the set of possible object names   is: <code>{'torch.nn.modules.linear.Linear', 'my_package.MyClass'}</code>.</li> <li>Step 3. The last step tries to import the object.   If the object can be imported, it returns the full name of the object.   If the object cannot be imported, it returns <code>None</code>.   This step is useful to manage the case where there are multiple ways to import an object.   For example if the query name is <code>torch.nn.Linear</code>, it will find that the real full   name is <code>torch.nn.modules.linear.Linear</code>.</li> </ul>"},{"location":"name_resolution/#matching-mechanism","title":"Matching mechanism","text":"<p>This section explains the matching mechanism used in the step 2 of the name resolution mechanism. Similarly to the name resolution mechanism, the inputs of the matching mechanism are a query name, and a set of object names. The matching mechanism returns a set of matches. First, the matching mechanism looks at if the query name is a valid python identifier. You can read this page to learn more about the Python identifier. If the query name is not a valid python identifier, the matching mechanism returns an empty set. If the query name is a valid python identifier, it finds the matches between the query name, and the python identifier of each object name in the set of object names. It returns the set of matches.</p>"},{"location":"name_resolution/#ignore-new-import","title":"Ignore new import","text":"<p>It is possible to ignore the new imports in the third step by setting <code>allow_import=False</code>. In some cases, we do not want to use an object which is not in the set of object names. By default, the name resolution mechanism returns the full name of the object if the import was successful in the third step. If <code>allow_import=False</code>, the name resolution mechanism tries to import the object and check if the name is in the set of object names. If we use the example presented above on <code>torch.nn.Linear</code>, we can write something:</p> <pre><code>from objectory.utils import resolve_name\n\nprint(\n    resolve_name(\n        \"torch.nn.Linear\", {\"torch.nn.modules.linear.Linear\"}, allow_import=False\n    )\n)\n</code></pre> <p>Output:</p> <pre><code>torch.nn.modules.linear.Linear\n</code></pre> <p>The name resolution mechanism finds that the full name of <code>torch.nn.Linear</code> is <code>torch.nn.modules.linear.Linear</code>. If <code>torch.nn.modules.linear.Linear</code> is not in the set of object names, the name resolution mechanism does not find the full name and returns <code>None</code>:</p> <pre><code>from objectory.utils import resolve_name\n\nprint(resolve_name(\"torch.nn.Linear\", {\"something.my_linear\"}, allow_import=False))\n</code></pre> <p>Output:</p> <pre><code>None\n</code></pre>"},{"location":"registry/","title":"Registry","text":"<p>The <code>Registry</code> can be used to register a class or a function.</p>"},{"location":"registry/#register-an-object","title":"Register an object","text":"<p>This section explains the basics on how to register an object (class or function). There are two approaches to register an object to the registry:</p> <ul> <li>by using the decorator <code>register</code></li> <li>by using the function <code>register_object</code></li> </ul>"},{"location":"registry/#decorator-register","title":"Decorator <code>register</code>","text":"<p>You can use the decorator <code>register</code> to register an object to the registry. For example if you want to register the class <code>ClassToRegister</code>, you can write:</p> <pre><code># file: my_package/my_module.py\nfrom objectory import Registry\n\nregistry = Registry()\n\n\n@registry.register()\nclass ClassToRegister:\n    pass\n\n\nprint(registry.registered_names())\n</code></pre> <p>Output:</p> <pre><code>{'my_package.my_module.ClassToRegister'}\n</code></pre> <p>The class <code>ClassToRegister</code> is registered with the name <code>my_package.my_module.ClassToRegister</code>. You can see the registered names by using the function <code>registered_names</code>. The function <code>registered_names</code> returns the set of registered names.</p> <p>You can also use the decorator <code>register</code> to register a function:</p> <pre><code># file: my_package/my_module.py\nfrom objectory import Registry\n\nregistry = Registry()\n\n\n@registry.register()\ndef function_to_register(*args, **kwargs):\n    pass\n\n\nprint(registry.registered_names())\n</code></pre> <p>Output:</p> <pre><code>{'my_package.my_module.function_to_register'}\n</code></pre> <p>The function <code>function_to_register</code> is registered with the name <code>my_package.my_module.function_to_register</code>.</p>"},{"location":"registry/#function-register_object","title":"Function <code>register_object</code>","text":"<p>The decorator approach works well when you can change the source code, but it will not work if you cannot modify the source code. You cannot use the decorator <code>register</code> to register an object in a third party library. To register a class or function from a third party library, you can use the function <code>register_object</code>. For example if you want to register the class <code>ClassToRegister</code> of the library <code>third_party</code>, you can write the following lines:</p> <pre><code># file: my_package/my_module.py\nfrom objectory import Registry\nfrom third_party import ClassToRegister\n\nregistry = Registry()\n\nregistry.register_object(ClassToRegister)\n</code></pre> <p>Similarly to the decorator <code>register</code>, you can use the function <code>register_object</code> to register a function:</p> <pre><code># file: my_package/my_module.py\nfrom objectory import Registry\nfrom third_party import function_to_register\n\nregistry = Registry()\n\nregistry.register_object(function_to_register)\n</code></pre> <p> It is not possible to register a lambda function. Please use a regular python function instead. The registry will raise the exception <code>IncorrectObjectFactoryError</code> if you try to register a lambda function.</p>"},{"location":"registry/#advanced-object-registration","title":"Advanced object registration","text":"<p>This section presents some advanced features to register an object.</p>"},{"location":"registry/#sub-registry","title":"Sub-registry","text":"<p>Previously we showed how to register an object to the registry, but all the objects will be registered to the same registry which can be messy in some cases. Instead, you can decide to use a hierarchical structure and to use sub-registries. The registry will have a tree structure. <code>registry</code> is the main registry, and you can add some sub-registries. Each sub-registry works like the main registry. In fact, the main registry and the sub-registries are implemented with the same class (<code>Registry</code>). It is not a hard coded rule, but it is recommended to use one sub-registry for each \"family\" of objects to group the similar objects.</p> <p>If you want to register the class in the sub-registry <code>other</code>, you can write:</p> <pre><code># file: my_package/my_module.py\nfrom objectory import Registry\n\nregistry = Registry()\n\n\n@registry.other.register()\nclass ClassToRegister:\n    pass\n\n\nprint(registry.registered_names())\nprint(registry.other.registered_names())\n</code></pre> <p>Output:</p> <pre><code>{'other'}\n{'my_package.my_module.ClassToRegister'}\n</code></pre> <p>You can check the registered objects in <code>registry</code> and <code>registry.other</code>. The class <code>ClassToRegister</code> is registered into <code>registry.other</code> and not <code>registry</code>. Note that the sub-registry <code>other</code> is registered to the main registry with the name <code>other</code>. It means you cannot use the name <code>other</code> to register an object. Each sub-registry is considered as a registered object in the parent registry. The sub-registry <code>other</code> will be created if it does not exist, so you do not have to manually register the new sub-registry. It is possible to have a nested structure where you add a sub-registry to a sub-registry:</p> <pre><code>from objectory import Registry\n\nregistry = Registry()\n\n\n@registry.animal.cat.register()\nclass MyCat:\n    pass\n\n\n@registry.animal.bear.register()\nclass MyBear:\n    pass\n</code></pre>"},{"location":"registry/#register-all-the-child-classes","title":"Register all the child classes","text":"<p>In some cases, you may want to register a class and all its child classes. Instead of doing manually, you can use the function <code>register_child_classes</code>. This function will automatically register the given class and all its child classes. It will find all the child classes and will add them to the registry. It finds the child classes recursively, so it will also find the child classes of the child classes.</p> <p>Let's imagine you have the following classes and you want to register them.</p> <pre><code># file: my_package/my_module.py\nfrom objectory import Registry\n\n\nclass Foo:\n    pass\n\n\nclass Bar(Foo):\n    pass\n\n\nclass Baz(Foo):\n    pass\n\n\nclass Bing(Bar):\n    pass\n\n\nregistry = Registry()\n\n# If you want to register Foo and all its child classes.\nregistry.register_child_classes(Foo)\nprint(registry.registered_names())\n\n# If you want to register Bar and all its child classes.\nregistry.bar.register_child_classes(Bar)\nprint(registry.bar.registered_names())\n</code></pre> <p>Output:</p> <pre><code>{'my_package.my_module.Foo', 'my_package.my_module.Baz',\n 'my_package.my_module.Bing', 'my_package.my_module.Bar'}\n{'my_package.my_module.Bing', 'my_package.my_module.Bar'}\n</code></pre> <p>By default, the function <code>register_child_classes</code> ignores all the abstract classes because you cannot instantiate them. If you want to also register the abstract classes, you can use the argument <code>ignore_abstract_class=False</code>. The following example shows how to register all the <code>torch.nn.Module</code> including the abstract classes.</p> <pre><code>import torch\nfrom objectory import Registry\n\nregistry = Registry()\nregistry.register_child_classes(torch.nn.Module, ignore_abstract_class=False)\n</code></pre>"},{"location":"registry/#customized-name","title":"Customized name","text":"<p>By default, the registry uses the full name of the object to identify the object in the registry. It is possible to customize the name used to register an object. For example if you want to register the class <code>ClassToRegister</code> with the name <code>my_class</code>, you can write the following code:</p> <pre><code># file: my_package/my_module.py\nfrom objectory import Registry\n\nregistry = Registry()\n\n\n@registry.register(\"my_class\")\nclass ClassToRegister:\n    pass\n\n\nregistry.register_object(ClassToRegister, \"my_class\")\n# or\nregistry.register_object(ClassToRegister, name=\"my_class\")\n</code></pre> <p>One of the advantage of using customizable names is that you can define shorter name: <code>my_class</code> is shorter than <code>my_package.my_module.ClassToRegister</code>. But using customizable names is not a free lunch, and it has a cost: it will be your responsibility to manage the names to avoid the conflicts. If two objects are registered with the same name, only the last object will be registered. For this reason, it is recommended to use the full name (default) because the full name is unique.</p> <p>Please think carefully about the pros and cons of this feature before to use it. In most of the cases you probably do not need it. Keep in mind that with power comes responsibility.</p>"},{"location":"registry/#factory","title":"Factory","text":"<p>The reserved keywords are:</p> <ul> <li><code>_target_</code>: the class/function to instantiate</li> <li><code>_init_</code>: the constructor to use to instantiate a class</li> </ul>"},{"location":"registry/#remove-objects","title":"Remove objects","text":"<p>In the previous sections, we explain how to add objects to the registry. In this section, we will explain how to remove them.</p>"},{"location":"registry/#remove-all-the-objects","title":"Remove all the objects","text":"<p>If you want to remove all the objects in a registry, you can use the function <code>clear</code>:</p> <pre><code>from objectory import Registry\n\nregistry = Registry()\n\n\nclass ClassToRegister:\n    pass\n\n\nregistry.register_object(ClassToRegister)\nprint(registry.registered_names())\n\nregistry.clear()\nprint(registry.registered_names())\n</code></pre> <p>Output:</p> <pre><code>set()\n</code></pre> <p>This function remove all the registered objects including the sub-registries. For example, if the registry has a sub-registry <code>other</code>, this line of code will also clear the sub-registry <code>other</code>. You can use this function on a sub-registry to clear only this sub-registry. For example, you can use the following command to remove all the classes and functions registered in the sub-registry <code>other</code>:</p> <pre><code>from objectory import Registry\n\nregistry = Registry()\n\nregistry.other.clear()\nprint(registry.other.registered_names())\n</code></pre> <p>Output:</p> <pre><code>set()\n</code></pre> <p>Note that by default, the function <code>clear</code> removes the sub-registries from the current registry but it does not clear the sub-registries.</p> <pre><code># file: my_package/my_module.py\nfrom objectory import Registry\n\nregistry = Registry()\n\n\nclass ClassToRegister:\n    pass\n\n\nregistry.other.register_object(ClassToRegister)\nregistry_other = registry.other\n\nregistry.clear()\nprint(registry.registered_names())\nprint(registry_other.registered_names())\n</code></pre> <p>Output:</p> <pre><code>set()\n{'my_package.my_module.ClassToRegister'}\n</code></pre> <p>To also clear all the sub-registries, you can set <code>nested=True</code> and the sub-registry <code>other</code> is also cleared.</p> <pre><code># file: my_package/my_module.py\nfrom objectory import Registry\n\nregistry = Registry()\n\n\nclass ClassToRegister:\n    pass\n\n\nregistry.other.register_object(ClassToRegister)\nregistry_other = registry.other\n\nregistry.clear(nested=True)\nprint(registry.registered_names())\nprint(registry_other.registered_names())\n</code></pre> <p>Output:</p> <pre><code>set()\nset()\n</code></pre>"},{"location":"registry/#remove-a-specific-object","title":"Remove a specific object","text":"<p>The function <code>clear</code> is useful to remove all the objects in the registry, but it does not work if you want to only remove a registered object and keep all the other registered objects.</p> <pre><code># file: my_package/my_module.py\nfrom objectory import Registry\n\nregistry = Registry()\n\n\n@registry.register()\nclass ClassToRegister1:\n    pass\n\n\n@registry.register()\nclass ClassToRegister2:\n    pass\n\n\nprint(registry.registered_names())\nregistry.unregister(\"my_package.my_module.ClassToRegister1\")\nprint(registry.registered_names())\n</code></pre> <p>Output:</p> <pre><code>{'my_package.my_module.ClassToRegister1', 'my_package.my_module.ClassToRegister2'}\n{'my_package.my_module.ClassToRegister2'}\n</code></pre> <p>If the object name is unique in the registry, you can only specify the object name:</p> <pre><code>from objectory import Registry\n\nregistry = Registry()\n\nregistry.unregister(\"ClassToRegister\")\n# is equivalent to\nregistry.unregister(\"my_package.my_module.ClassToRegister\")\n</code></pre> <p>Please read the name resolution documentation to learn more about this feature.</p>"},{"location":"registry/#filters","title":"Filters","text":""},{"location":"registry/#child-class-filter","title":"Child class filter","text":"<p>Usually you want to control the objects that you want to add to the registry. For example, it is usually a good idea to register similar objects in the same registry. A usual scenario is to define a base class, and then register only the child classes of the base class. For example if you want to register <code>torch.nn.Module</code>, you probably want to check that the object is a <code>torch.nn.Module</code> before to register it. Let's imagine you want to register only <code>torch.nn.Module</code> in the sub-registry <code>other</code>.</p> <pre><code>import torch\nfrom objectory import Registry\n\nregistry = Registry()\n\nregistry.set_class_filter(torch.nn.Module)\nregistry.register_object(torch.nn.Linear)\nregistry.register_object(torch.nn.Conv2d)\n...\n</code></pre> <p>You can only register classes that inherits torch.nn.Module in the sub-registry <code>other</code>. If you try to register a class which is not a child class, the registry will raise the exception <code>IncorrectObjectFactoryError</code>:</p> <pre><code>import torch\nfrom objectory import Registry\n\nregistry = Registry()\n\n\nclass Foo:\n    pass\n\n\nregistry.set_class_filter(torch.nn.Module)\nregistry.register_object(Foo)\n</code></pre> <p>The previous example will raise an exception because <code>Foo</code> is not a child class of <code>torch.nn.Module</code>. To unset the class filter, you can set it to <code>None</code>:</p> <pre><code>from objectory import Registry\n\nregistry = Registry()\nregistry.set_class_filter(None)\n</code></pre> <p> Note that the class filter is only used when you try to register a new object. It will not filter the existing objects into the registry. You can look at the following example:</p> <pre><code># file: my_package/my_module.py\nimport torch\n\nfrom objectory import Registry\n\n\nclass Foo:\n    pass\n\n\nregistry = Registry()\nregistry.register_object(Foo)\nprint(registry.registered_names())\n\nregistry.set_class_filter(torch.nn.Module)\nregistry.register_object(torch.nn.Linear)\nprint(registry.registered_names())\n</code></pre> <p>Output:</p> <pre><code>{'my_package.my_module.Foo'}\n{'my_package.my_module.Foo', 'torch.nn.Linear'}\n</code></pre> <p>You can see that the class <code>my_package.my_module.Foo</code> is still registered after the filter is set to <code>torch.nn.Module</code>. It is because this class was added before to set the class filter. If you want to filter all the objects before to add them to the registry, please set the class filter before to register the first object. It will guarantee that all the registered objects are inherited from the filtered class.</p>"},{"location":"registry/#clear-all-filters","title":"Clear all filters","text":"<p>You can remove all the filters of a registry by using the function <code>clear_filters</code>:</p> <pre><code>from objectory import Registry\n\nregistry = Registry()\nregistry.clear_filters()\n</code></pre> <p>By default, the function <code>clear_filters</code> removes the filters on the current registry but not the filters of the sub-registries. To also remove the filters of all the sub-registries, you can set <code>nested=True</code>:</p> <pre><code>from objectory import Registry\n\nregistry = Registry()\nregistry.clear_filters(nested=True)\n</code></pre>"},{"location":"refs/","title":"Main classes and functions","text":""},{"location":"refs/#objectory","title":"objectory","text":"<p>Contain the main features of the <code>objectory</code> package.</p>"},{"location":"refs/#objectory.AbstractFactory","title":"objectory.AbstractFactory","text":"<p>             Bases: <code>ABCMeta</code></p> <p>Implement the abstract factory metaclass to create automatically factories.</p> <p>Please read the documentation about this abstract factory to learn how it works and how to use it.</p> <p>To avoid potential conflicts with the other classes, all the non-public attributes or functions starts with <code>_abstractfactory_****</code> where <code>****</code> is the name of the attribute or the function.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Specifies the class name. This becomes the <code>__name__</code> attribute of the class.</p> required <code>bases</code> <code>tuple</code> <p>Specifies a tuple of the base classes from which the class inherits. This becomes the <code>__bases__</code> attribute of the class.</p> required <code>dct</code> <code>dict</code> <p>Specifies a namespace dictionary containing definitions for the class body. This becomes the <code>__dict__</code> attribute of the class.</p> required <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from objectory import AbstractFactory\n&gt;&gt;&gt; class BaseClass(metaclass=AbstractFactory):\n...     pass\n...\n&gt;&gt;&gt; class MyClass(BaseClass):\n...     pass\n...\n&gt;&gt;&gt; obj = BaseClass.factory(\"MyClass\")\n&gt;&gt;&gt; obj\n&lt;....MyClass object at 0x...&gt;\n</code></pre>"},{"location":"refs/#objectory.AbstractFactory.inheritors","title":"objectory.AbstractFactory.inheritors  <code>property</code>","text":"<pre><code>inheritors: dict[str, Any]\n</code></pre> <p>Get the inheritors.</p> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>The inheritors.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from objectory import AbstractFactory\n&gt;&gt;&gt; class BaseClass(metaclass=AbstractFactory):\n...     pass\n...\n&gt;&gt;&gt; class MyClass(BaseClass):\n...     pass\n...\n&gt;&gt;&gt; BaseClass.inheritors\n{'....BaseClass': &lt;class '....BaseClass'&gt;, '....MyClass': &lt;class '....MyClass'&gt;}\n</code></pre>"},{"location":"refs/#objectory.AbstractFactory.factory","title":"objectory.AbstractFactory.factory","text":"<pre><code>factory(\n    _target_: str,\n    *args: Any,\n    _init_: str = \"__init__\",\n    **kwargs: Any\n) -&gt; Any\n</code></pre> <p>Instantiate dynamically an object given its configuration.</p> <p>Please read the documentation for more information.</p> <p>Parameters:</p> Name Type Description Default <code>_target_</code> <code>str</code> <p>Specifies the name of the object (class or function) to instantiate. It can be the class name or the full class name.</p> required <code>*args</code> <code>Any</code> <p>Variable length argument list.</p> <code>()</code> <code>_init_</code> <code>str</code> <p>Specifies the function to use to create the object. If <code>\"__init__\"</code>, the object is created by calling the constructor.</p> <code>'__init__'</code> <code>**kwargs</code> <code>Any</code> <p>Arbitrary keyword arguments.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Any</code> <p>The instantiated object with the given parameters.</p> <p>Raises:</p> Type Description <code>AbstractClassAbstractFactoryError</code> <p>if you try to instantiate an abstract class.</p> <code>UnregisteredClassAbstractFactoryError</code> <p>if the target is not found.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from objectory import AbstractFactory\n&gt;&gt;&gt; class BaseClass(metaclass=AbstractFactory):\n...     pass\n...\n&gt;&gt;&gt; class MyClass(BaseClass):\n...     pass\n...\n&gt;&gt;&gt; obj = BaseClass.factory(\"MyClass\")\n&gt;&gt;&gt; obj\n&lt;....MyClass object at 0x...&gt;\n</code></pre>"},{"location":"refs/#objectory.AbstractFactory.register_object","title":"objectory.AbstractFactory.register_object","text":"<pre><code>register_object(obj: type | Callable) -&gt; None\n</code></pre> <p>Register a class or function to the factory. It is useful if you are using a 3rd party library.</p> <p>For example, you use a 3rd party library, and you cannot modify the classes to add <code>AbstractFactory</code>. You can use this function to register some classes or functions of a 3rd party library.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>type | Callable</code> <p>Specifies the class or function to register to the factory.</p> required <p>Raises:</p> Type Description <code>IncorrectObjectAbstractFactoryError</code> <p>if the object is not a class.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from objectory import AbstractFactory\n&gt;&gt;&gt; class BaseClass(metaclass=AbstractFactory):\n...     pass\n...\n&gt;&gt;&gt; class MyClass:\n...     pass\n...\n&gt;&gt;&gt; BaseClass.register_object(MyClass)\n&gt;&gt;&gt; BaseClass.inheritors\n{...}\n</code></pre>"},{"location":"refs/#objectory.AbstractFactory.unregister","title":"objectory.AbstractFactory.unregister","text":"<pre><code>unregister(name: str) -&gt; None\n</code></pre> <p>Remove a registered object from the factory.</p> <p>This is an experimental function and may change in the future.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Specifies the name of the object to remove. This function uses the name resolution mechanism to find the full name if only the short name is given.</p> required <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from objectory import AbstractFactory\n&gt;&gt;&gt; class BaseClass(metaclass=AbstractFactory):\n...     pass\n...\n&gt;&gt;&gt; class MyClass:\n...     pass\n...\n&gt;&gt;&gt; BaseClass.register_object(MyClass)\n&gt;&gt;&gt; BaseClass.unregister(\"MyClass\")\n&gt;&gt;&gt; BaseClass.inheritors\n{'....BaseClass': &lt;class '....BaseClass'&gt;}\n</code></pre>"},{"location":"refs/#objectory.Registry","title":"objectory.Registry","text":"<p>Implement the registry class.</p> <p>This class can be used to register some objects and instantiate an object from its configuration.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from objectory import Registry\n&gt;&gt;&gt; from collections import Counter\n&gt;&gt;&gt; registry = Registry()\n&gt;&gt;&gt; registry.register_object(Counter)\n&gt;&gt;&gt; registry.factory(\"collections.Counter\")\nCounter()\n</code></pre>"},{"location":"refs/#objectory.Registry.__getattr__","title":"objectory.Registry.__getattr__","text":"<pre><code>__getattr__(key: str) -&gt; Registry | type\n</code></pre> <p>Get the registry associated to a key.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>Specifies the key.</p> required <p>Returns:</p> Type Description <code>Registry | type</code> <p>The registry associated to the key.</p> <p>Raises:</p> Type Description <code>InvalidAttributeRegistryError</code> <p>if the associated attribute is not a registry.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from collections import Counter\n&gt;&gt;&gt; registry = Registry()\n&gt;&gt;&gt; registry.other.register_object(Counter)\n</code></pre>"},{"location":"refs/#objectory.Registry.__len__","title":"objectory.Registry.__len__","text":"<pre><code>__len__() -&gt; int\n</code></pre> <p>Return the number of registered objects.</p> <p>Returns:</p> Type Description <code>int</code> <p>The number of registered objects.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from objectory import Registry\n&gt;&gt;&gt; from collections import Counter\n&gt;&gt;&gt; registry = Registry()\n&gt;&gt;&gt; registry.register_object(Counter)\n&gt;&gt;&gt; len(registry)\n1\n</code></pre>"},{"location":"refs/#objectory.Registry.clear","title":"objectory.Registry.clear","text":"<pre><code>clear(nested: bool = False) -&gt; None\n</code></pre> <p>Clear the registry.</p> <p>This functions removes all the registered objects in the registry.</p> <p>Parameters:</p> Name Type Description Default <code>nested</code> <code>bool</code> <p>Indicates if the sub-registries should be cleared or not.</p> <code>False</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from objectory import Registry\n&gt;&gt;&gt; registry = Registry()\n&gt;&gt;&gt; # Clear the main registry.\n&gt;&gt;&gt; registry.clear()\n&gt;&gt;&gt; # Clear only the sub-registry other.\n&gt;&gt;&gt; registry.other.clear()\n&gt;&gt;&gt; # Clear the main registry and its sub-registries.\n&gt;&gt;&gt; registry.clear(nested=True)\n</code></pre>"},{"location":"refs/#objectory.Registry.clear_filters","title":"objectory.Registry.clear_filters","text":"<pre><code>clear_filters(nested: bool = False) -&gt; None\n</code></pre> <p>Clear all the filters of the registry.</p> <p>Parameters:</p> Name Type Description Default <code>nested</code> <code>bool</code> <p>Indicates if the filters of all the sub-registries should be cleared or not.</p> <code>False</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from objectory import Registry\n&gt;&gt;&gt; registry = Registry()\n&gt;&gt;&gt; # Clear the filters of the main registry.\n&gt;&gt;&gt; registry.clear_filters()\n&gt;&gt;&gt; # Clear the filters of the sub-registry other.\n&gt;&gt;&gt; registry.other.clear_filters()\n&gt;&gt;&gt; # Clear the filters of the main registry and all its sub-registries.\n&gt;&gt;&gt; registry.clear_filters(nested=True)\n</code></pre>"},{"location":"refs/#objectory.Registry.factory","title":"objectory.Registry.factory","text":"<pre><code>factory(\n    _target_: str,\n    *args: Any,\n    _init_: str = \"__init__\",\n    **kwargs: Any\n) -&gt; Any\n</code></pre> <p>Instantiate dynamically an object given its configuration.</p> <p>Please read the documentation for more information.</p> <p>Parameters:</p> Name Type Description Default <code>_target_</code> <p>Specifies the name of the object (class or function) to instantiate. It can be the class name or the full class name.</p> required <code>*args</code> <code>Any</code> <p>Variable length argument list.</p> <code>()</code> <code>_init_</code> <code>str</code> <p>Specifies the function to use to create the object. If <code>\"__init__\"</code>, the object is created by calling the constructor.</p> <code>'__init__'</code> <code>**kwargs</code> <code>Any</code> <p>Arbitrary keyword arguments.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Any</code> <p>The instantiated object with the given parameters.</p> <p>Raises:</p> Type Description <code>AbstractClassAbstractFactoryError</code> <p>if you try to instantiate an abstract class.</p> <code>UnregisteredClassAbstractFactoryError</code> <p>if the target name is not found.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from objectory import Registry\n&gt;&gt;&gt; registry = Registry()\n&gt;&gt;&gt; @registry.register()\n... class MyClass:\n...     pass\n...\n&gt;&gt;&gt; registry.factory(\"MyClass\")\n&lt;....MyClass object at 0x...&gt;\n</code></pre>"},{"location":"refs/#objectory.Registry.register","title":"objectory.Registry.register","text":"<pre><code>register(name: str | None = None) -&gt; Callable\n</code></pre> <p>Define a decorator to add a class or a function to the registry.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str | None</code> <p>Specifies the name to use to register the object. If <code>None</code>, the full name of the object is used as name.</p> <code>None</code> <p>Returns:</p> Type Description <code>Callable</code> <p>The decorated object.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from objectory import Registry\n&gt;&gt;&gt; registry = Registry()\n&gt;&gt;&gt; @registry.register()\n... class ClassToRegister:\n...     pass\n...\n&gt;&gt;&gt; registry.registered_names()\n{'....ClassToRegister'}\n&gt;&gt;&gt; @registry.register()\n... def function_to_register(*args, **kwargs):\n...     pass\n...\n&gt;&gt;&gt; registry.registered_names()\n{...}\n</code></pre>"},{"location":"refs/#objectory.Registry.register_child_classes","title":"objectory.Registry.register_child_classes","text":"<pre><code>register_child_classes(\n    cls: type, ignore_abstract_class: bool = True\n) -&gt; None\n</code></pre> <p>Register a given class and its child classes of a given class.</p> <p>This function registers all the child classes including the child classes of the child classes, etc. If you use this function, you cannot choose the names used to register the objects. It will use the full name of each object.</p> <p>Parameters:</p> Name Type Description Default <code>cls</code> <code>type</code> <p>Specifies the class to register its child classes.</p> required <code>ignore_abstract_class</code> <code>bool</code> <p>Indicate if the abstract class should be ignored or not. Be default, the abstract classes are not registered because they cannot be instantiated.</p> <code>True</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from objectory import Registry\n&gt;&gt;&gt; registry = Registry()\n&gt;&gt;&gt; registry.register_child_classes(dict)\n&gt;&gt;&gt; registry.registered_names()\n{...}\n</code></pre>"},{"location":"refs/#objectory.Registry.register_object","title":"objectory.Registry.register_object","text":"<pre><code>register_object(\n    obj: type | Callable, name: str | None = None\n) -&gt; None\n</code></pre> <p>Register an object.</p> <p>Please read the documentation for more information.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>type | Callable</code> <p>Specifies the object to register. The object is expected to be a class or a function.</p> required <code>name</code> <code>str | None</code> <p>Specifies the name to use to register the object. If <code>None</code>, the full name of the object is used as name.</p> <code>None</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from objectory import Registry\n&gt;&gt;&gt; registry = Registry()\n&gt;&gt;&gt; class ClassToRegister:\n...     pass\n...\n&gt;&gt;&gt; registry.register_object(ClassToRegister)\n&gt;&gt;&gt; registry.registered_names()\n{'....ClassToRegister'}\n&gt;&gt;&gt; def function_to_register(*args, **kwargs):\n...     pass\n...\n&gt;&gt;&gt; registry.register_object(function_to_register)\n&gt;&gt;&gt; registry.registered_names()\n{...}\n</code></pre>"},{"location":"refs/#objectory.Registry.registered_names","title":"objectory.Registry.registered_names","text":"<pre><code>registered_names(include_registry: bool = True) -&gt; set[str]\n</code></pre> <p>Get the names of all the registered objects.</p> <p>Parameters:</p> Name Type Description Default <code>include_registry</code> <code>bool</code> <p>Specifies if the other (sub-)registries should be included in the set. By default, the other (sub-)registries are included.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>set</code> <code>set[str]</code> <p>The names of the registered objects.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from objectory import Registry\n&gt;&gt;&gt; registry = Registry()\n&gt;&gt;&gt; registry.registered_names()\n&gt;&gt;&gt; # Show name of all the registered objects except the sub-registries.\n&gt;&gt;&gt; registry.registered_names(include_registry=False)\n</code></pre>"},{"location":"refs/#objectory.Registry.set_class_filter","title":"objectory.Registry.set_class_filter","text":"<pre><code>set_class_filter(cls: type | None) -&gt; None\n</code></pre> <p>Set the class filter so only the child classes of this class can be registered.</p> <p>If you set this filter, you cannot register functions. To unset this filter, you can use <code>set_class_filter(None)</code>.</p> <p>Parameters:</p> Name Type Description Default <code>cls</code> <code>type | None</code> <p>Specifies the class to use as filter. Only the child classes of this class can be registered.</p> required <p>Raises:</p> Type Description <code>TypeError</code> <p>if the input is not a class or <code>None</code>.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from collections import Counter, OrderedDict\n&gt;&gt;&gt; from objectory import Registry\n&gt;&gt;&gt; registry = Registry()\n&gt;&gt;&gt; registry.mapping.set_class_filter(dict)\n&gt;&gt;&gt; registry.mapping.register_object(OrderedDict)\n&gt;&gt;&gt; registry.mapping.registered_names()\n{'collections.OrderedDict'}\n</code></pre>"},{"location":"refs/#objectory.Registry.unregister","title":"objectory.Registry.unregister","text":"<pre><code>unregister(name: str) -&gt; None\n</code></pre> <p>Remove a registered object.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Specifies the name of the object to remove. This function uses the name resolution mechanism to find the full name if only the short name is given.</p> required <p>Raises:</p> Type Description <code>UnregisteredObjectFactoryError</code> <p>if the name does not exist in the registry.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from objectory import Registry\n&gt;&gt;&gt; from collections import Counter\n&gt;&gt;&gt; registry = Registry()\n&gt;&gt;&gt; registry.register_object(Counter)\n&gt;&gt;&gt; registry.unregister(\"collections.Counter\")\n</code></pre>"},{"location":"refs/#objectory.factory","title":"objectory.factory","text":"<pre><code>factory(\n    _target_: str,\n    *args: Any,\n    _init_: str = \"__init__\",\n    **kwargs: Any\n) -&gt; Any\n</code></pre> <p>Instantiate dynamically an object given its configuration.</p> <p>Parameters:</p> Name Type Description Default <code>_target_</code> <code>str</code> <p>Specifies the name of the object (class or function) to instantiate. It can be the class name or the full class name.</p> required <code>*args</code> <code>Any</code> <p>Variable length argument list.</p> <code>()</code> <code>_init_</code> <code>str</code> <p>Specifies the function to use to create the object. If <code>\"__init__\"</code>, the object is created by calling the constructor.</p> <code>'__init__'</code> <code>**kwargs</code> <code>Any</code> <p>Arbitrary keyword arguments.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Any</code> <p>The instantiated object with the given parameters.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>if the target cannot be found.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from objectory import factory\n&gt;&gt;&gt; factory(\"collections.Counter\", [1, 2, 1, 3])\nCounter({1: 2, 2: 1, 3: 1})\n</code></pre>"},{"location":"refs/abstract_factory/","title":"Abstract factory","text":""},{"location":"refs/abstract_factory/#objectory.abstract_factory","title":"objectory.abstract_factory","text":"<p>Implement the <code>AbstractFactory</code> metaclass used to create abstract factories.</p>"},{"location":"refs/abstract_factory/#objectory.abstract_factory.AbstractFactory","title":"objectory.abstract_factory.AbstractFactory","text":"<p>             Bases: <code>ABCMeta</code></p> <p>Implement the abstract factory metaclass to create automatically factories.</p> <p>Please read the documentation about this abstract factory to learn how it works and how to use it.</p> <p>To avoid potential conflicts with the other classes, all the non-public attributes or functions starts with <code>_abstractfactory_****</code> where <code>****</code> is the name of the attribute or the function.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Specifies the class name. This becomes the <code>__name__</code> attribute of the class.</p> required <code>bases</code> <code>tuple</code> <p>Specifies a tuple of the base classes from which the class inherits. This becomes the <code>__bases__</code> attribute of the class.</p> required <code>dct</code> <code>dict</code> <p>Specifies a namespace dictionary containing definitions for the class body. This becomes the <code>__dict__</code> attribute of the class.</p> required <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from objectory import AbstractFactory\n&gt;&gt;&gt; class BaseClass(metaclass=AbstractFactory):\n...     pass\n...\n&gt;&gt;&gt; class MyClass(BaseClass):\n...     pass\n...\n&gt;&gt;&gt; obj = BaseClass.factory(\"MyClass\")\n&gt;&gt;&gt; obj\n&lt;....MyClass object at 0x...&gt;\n</code></pre>"},{"location":"refs/abstract_factory/#objectory.abstract_factory.AbstractFactory.inheritors","title":"objectory.abstract_factory.AbstractFactory.inheritors  <code>property</code>","text":"<pre><code>inheritors: dict[str, Any]\n</code></pre> <p>Get the inheritors.</p> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>The inheritors.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from objectory import AbstractFactory\n&gt;&gt;&gt; class BaseClass(metaclass=AbstractFactory):\n...     pass\n...\n&gt;&gt;&gt; class MyClass(BaseClass):\n...     pass\n...\n&gt;&gt;&gt; BaseClass.inheritors\n{'....BaseClass': &lt;class '....BaseClass'&gt;, '....MyClass': &lt;class '....MyClass'&gt;}\n</code></pre>"},{"location":"refs/abstract_factory/#objectory.abstract_factory.AbstractFactory.factory","title":"objectory.abstract_factory.AbstractFactory.factory","text":"<pre><code>factory(\n    _target_: str,\n    *args: Any,\n    _init_: str = \"__init__\",\n    **kwargs: Any\n) -&gt; Any\n</code></pre> <p>Instantiate dynamically an object given its configuration.</p> <p>Please read the documentation for more information.</p> <p>Parameters:</p> Name Type Description Default <code>_target_</code> <code>str</code> <p>Specifies the name of the object (class or function) to instantiate. It can be the class name or the full class name.</p> required <code>*args</code> <code>Any</code> <p>Variable length argument list.</p> <code>()</code> <code>_init_</code> <code>str</code> <p>Specifies the function to use to create the object. If <code>\"__init__\"</code>, the object is created by calling the constructor.</p> <code>'__init__'</code> <code>**kwargs</code> <code>Any</code> <p>Arbitrary keyword arguments.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Any</code> <p>The instantiated object with the given parameters.</p> <p>Raises:</p> Type Description <code>AbstractClassAbstractFactoryError</code> <p>if you try to instantiate an abstract class.</p> <code>UnregisteredClassAbstractFactoryError</code> <p>if the target is not found.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from objectory import AbstractFactory\n&gt;&gt;&gt; class BaseClass(metaclass=AbstractFactory):\n...     pass\n...\n&gt;&gt;&gt; class MyClass(BaseClass):\n...     pass\n...\n&gt;&gt;&gt; obj = BaseClass.factory(\"MyClass\")\n&gt;&gt;&gt; obj\n&lt;....MyClass object at 0x...&gt;\n</code></pre>"},{"location":"refs/abstract_factory/#objectory.abstract_factory.AbstractFactory.register_object","title":"objectory.abstract_factory.AbstractFactory.register_object","text":"<pre><code>register_object(obj: type | Callable) -&gt; None\n</code></pre> <p>Register a class or function to the factory. It is useful if you are using a 3rd party library.</p> <p>For example, you use a 3rd party library, and you cannot modify the classes to add <code>AbstractFactory</code>. You can use this function to register some classes or functions of a 3rd party library.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>type | Callable</code> <p>Specifies the class or function to register to the factory.</p> required <p>Raises:</p> Type Description <code>IncorrectObjectAbstractFactoryError</code> <p>if the object is not a class.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from objectory import AbstractFactory\n&gt;&gt;&gt; class BaseClass(metaclass=AbstractFactory):\n...     pass\n...\n&gt;&gt;&gt; class MyClass:\n...     pass\n...\n&gt;&gt;&gt; BaseClass.register_object(MyClass)\n&gt;&gt;&gt; BaseClass.inheritors\n{...}\n</code></pre>"},{"location":"refs/abstract_factory/#objectory.abstract_factory.AbstractFactory.unregister","title":"objectory.abstract_factory.AbstractFactory.unregister","text":"<pre><code>unregister(name: str) -&gt; None\n</code></pre> <p>Remove a registered object from the factory.</p> <p>This is an experimental function and may change in the future.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Specifies the name of the object to remove. This function uses the name resolution mechanism to find the full name if only the short name is given.</p> required <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from objectory import AbstractFactory\n&gt;&gt;&gt; class BaseClass(metaclass=AbstractFactory):\n...     pass\n...\n&gt;&gt;&gt; class MyClass:\n...     pass\n...\n&gt;&gt;&gt; BaseClass.register_object(MyClass)\n&gt;&gt;&gt; BaseClass.unregister(\"MyClass\")\n&gt;&gt;&gt; BaseClass.inheritors\n{'....BaseClass': &lt;class '....BaseClass'&gt;}\n</code></pre>"},{"location":"refs/abstract_factory/#objectory.abstract_factory.is_abstract_factory","title":"objectory.abstract_factory.is_abstract_factory","text":"<pre><code>is_abstract_factory(cls: Any) -&gt; bool\n</code></pre> <p>Indicate if a class implements the <code>AbstractFactory</code> metaclass.</p> <p>Parameters:</p> Name Type Description Default <code>cls</code> <code>Any</code> <p>Specifies the class to check.</p> required <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the class implements the <code>AbstractFactory</code> metaclass, otherwise <code>False</code>.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from objectory.abstract_factory import AbstractFactory, is_abstract_factory\n&gt;&gt;&gt; class BaseClass(metaclass=AbstractFactory):\n...     pass\n...\n&gt;&gt;&gt; is_abstract_factory(BaseClass)\nTrue\n&gt;&gt;&gt; is_abstract_factory(int)\nFalse\n</code></pre>"},{"location":"refs/abstract_factory/#objectory.abstract_factory.register","title":"objectory.abstract_factory.register","text":"<pre><code>register(cls: AbstractFactory) -&gt; Callable\n</code></pre> <p>Define a decorator to register a function to a factory.</p> <p>This decorator is designed to register functions that returns an object of a class registered in the factory.</p> <p>Parameters:</p> Name Type Description Default <code>cls</code> <code>AbstractFactory</code> <p>Specifies the class where to register the function.</p> required <p>Returns:</p> Type Description <code>Callable</code> <p>collections.abc.Callable: The decorated function.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from objectory.abstract_factory import AbstractFactory, register\n&gt;&gt;&gt; class BaseClass(metaclass=AbstractFactory):\n...     pass\n...\n&gt;&gt;&gt; @register(BaseClass)\n... def function_to_register(value: int) -&gt; int:\n...     return value + 2\n...\n&gt;&gt;&gt; BaseClass.factory(\"function_to_register\", 40)\n42\n</code></pre>"},{"location":"refs/abstract_factory/#objectory.abstract_factory.register_child_classes","title":"objectory.abstract_factory.register_child_classes","text":"<pre><code>register_child_classes(\n    factory_cls: AbstractFactory | type,\n    cls: type,\n    ignore_abstract_class: bool = True,\n) -&gt; None\n</code></pre> <p>Register the given class and its child classes of a given class.</p> <p>This function registers all the child classes including the child classes of the child classes, etc.</p> <p>Parameters:</p> Name Type Description Default <code>factory_cls</code> <code>AbstractFactory | type</code> <p>Specifies the factory class. The child classes will be registered to this class.</p> required <code>cls</code> <code>type</code> <p>Specifies the class to register its child classes.</p> required <code>ignore_abstract_class</code> <code>bool</code> <p>Indicate if the abstract class should be ignored or not. Be default, the abstract classes are not registered because they cannot be instantiated.</p> <code>True</code> <p>Raises:</p> Type Description <code>AbstractFactoryTypeError</code> <p>if the factory class does not implement the <code>AbstractFactory</code> metaclass.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from objectory.abstract_factory import AbstractFactory, register_child_classes\n&gt;&gt;&gt; class BaseClass(metaclass=AbstractFactory):\n...     pass\n...\n&gt;&gt;&gt; register_child_classes(BaseClass, dict)\n</code></pre>"},{"location":"refs/registry/","title":"Registry","text":""},{"location":"refs/registry/#objectory.registry","title":"objectory.registry","text":"<p>Implement the registry class.</p>"},{"location":"refs/registry/#objectory.registry.Registry","title":"objectory.registry.Registry","text":"<p>Implement the registry class.</p> <p>This class can be used to register some objects and instantiate an object from its configuration.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from objectory import Registry\n&gt;&gt;&gt; from collections import Counter\n&gt;&gt;&gt; registry = Registry()\n&gt;&gt;&gt; registry.register_object(Counter)\n&gt;&gt;&gt; registry.factory(\"collections.Counter\")\nCounter()\n</code></pre>"},{"location":"refs/registry/#objectory.registry.Registry.__getattr__","title":"objectory.registry.Registry.__getattr__","text":"<pre><code>__getattr__(key: str) -&gt; Registry | type\n</code></pre> <p>Get the registry associated to a key.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>Specifies the key.</p> required <p>Returns:</p> Type Description <code>Registry | type</code> <p>The registry associated to the key.</p> <p>Raises:</p> Type Description <code>InvalidAttributeRegistryError</code> <p>if the associated attribute is not a registry.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from collections import Counter\n&gt;&gt;&gt; registry = Registry()\n&gt;&gt;&gt; registry.other.register_object(Counter)\n</code></pre>"},{"location":"refs/registry/#objectory.registry.Registry.__len__","title":"objectory.registry.Registry.__len__","text":"<pre><code>__len__() -&gt; int\n</code></pre> <p>Return the number of registered objects.</p> <p>Returns:</p> Type Description <code>int</code> <p>The number of registered objects.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from objectory import Registry\n&gt;&gt;&gt; from collections import Counter\n&gt;&gt;&gt; registry = Registry()\n&gt;&gt;&gt; registry.register_object(Counter)\n&gt;&gt;&gt; len(registry)\n1\n</code></pre>"},{"location":"refs/registry/#objectory.registry.Registry.clear","title":"objectory.registry.Registry.clear","text":"<pre><code>clear(nested: bool = False) -&gt; None\n</code></pre> <p>Clear the registry.</p> <p>This functions removes all the registered objects in the registry.</p> <p>Parameters:</p> Name Type Description Default <code>nested</code> <code>bool</code> <p>Indicates if the sub-registries should be cleared or not.</p> <code>False</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from objectory import Registry\n&gt;&gt;&gt; registry = Registry()\n&gt;&gt;&gt; # Clear the main registry.\n&gt;&gt;&gt; registry.clear()\n&gt;&gt;&gt; # Clear only the sub-registry other.\n&gt;&gt;&gt; registry.other.clear()\n&gt;&gt;&gt; # Clear the main registry and its sub-registries.\n&gt;&gt;&gt; registry.clear(nested=True)\n</code></pre>"},{"location":"refs/registry/#objectory.registry.Registry.clear_filters","title":"objectory.registry.Registry.clear_filters","text":"<pre><code>clear_filters(nested: bool = False) -&gt; None\n</code></pre> <p>Clear all the filters of the registry.</p> <p>Parameters:</p> Name Type Description Default <code>nested</code> <code>bool</code> <p>Indicates if the filters of all the sub-registries should be cleared or not.</p> <code>False</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from objectory import Registry\n&gt;&gt;&gt; registry = Registry()\n&gt;&gt;&gt; # Clear the filters of the main registry.\n&gt;&gt;&gt; registry.clear_filters()\n&gt;&gt;&gt; # Clear the filters of the sub-registry other.\n&gt;&gt;&gt; registry.other.clear_filters()\n&gt;&gt;&gt; # Clear the filters of the main registry and all its sub-registries.\n&gt;&gt;&gt; registry.clear_filters(nested=True)\n</code></pre>"},{"location":"refs/registry/#objectory.registry.Registry.factory","title":"objectory.registry.Registry.factory","text":"<pre><code>factory(\n    _target_: str,\n    *args: Any,\n    _init_: str = \"__init__\",\n    **kwargs: Any\n) -&gt; Any\n</code></pre> <p>Instantiate dynamically an object given its configuration.</p> <p>Please read the documentation for more information.</p> <p>Parameters:</p> Name Type Description Default <code>_target_</code> <p>Specifies the name of the object (class or function) to instantiate. It can be the class name or the full class name.</p> required <code>*args</code> <code>Any</code> <p>Variable length argument list.</p> <code>()</code> <code>_init_</code> <code>str</code> <p>Specifies the function to use to create the object. If <code>\"__init__\"</code>, the object is created by calling the constructor.</p> <code>'__init__'</code> <code>**kwargs</code> <code>Any</code> <p>Arbitrary keyword arguments.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Any</code> <p>The instantiated object with the given parameters.</p> <p>Raises:</p> Type Description <code>AbstractClassAbstractFactoryError</code> <p>if you try to instantiate an abstract class.</p> <code>UnregisteredClassAbstractFactoryError</code> <p>if the target name is not found.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from objectory import Registry\n&gt;&gt;&gt; registry = Registry()\n&gt;&gt;&gt; @registry.register()\n... class MyClass:\n...     pass\n...\n&gt;&gt;&gt; registry.factory(\"MyClass\")\n&lt;....MyClass object at 0x...&gt;\n</code></pre>"},{"location":"refs/registry/#objectory.registry.Registry.register","title":"objectory.registry.Registry.register","text":"<pre><code>register(name: str | None = None) -&gt; Callable\n</code></pre> <p>Define a decorator to add a class or a function to the registry.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str | None</code> <p>Specifies the name to use to register the object. If <code>None</code>, the full name of the object is used as name.</p> <code>None</code> <p>Returns:</p> Type Description <code>Callable</code> <p>The decorated object.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from objectory import Registry\n&gt;&gt;&gt; registry = Registry()\n&gt;&gt;&gt; @registry.register()\n... class ClassToRegister:\n...     pass\n...\n&gt;&gt;&gt; registry.registered_names()\n{'....ClassToRegister'}\n&gt;&gt;&gt; @registry.register()\n... def function_to_register(*args, **kwargs):\n...     pass\n...\n&gt;&gt;&gt; registry.registered_names()\n{...}\n</code></pre>"},{"location":"refs/registry/#objectory.registry.Registry.register_child_classes","title":"objectory.registry.Registry.register_child_classes","text":"<pre><code>register_child_classes(\n    cls: type, ignore_abstract_class: bool = True\n) -&gt; None\n</code></pre> <p>Register a given class and its child classes of a given class.</p> <p>This function registers all the child classes including the child classes of the child classes, etc. If you use this function, you cannot choose the names used to register the objects. It will use the full name of each object.</p> <p>Parameters:</p> Name Type Description Default <code>cls</code> <code>type</code> <p>Specifies the class to register its child classes.</p> required <code>ignore_abstract_class</code> <code>bool</code> <p>Indicate if the abstract class should be ignored or not. Be default, the abstract classes are not registered because they cannot be instantiated.</p> <code>True</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from objectory import Registry\n&gt;&gt;&gt; registry = Registry()\n&gt;&gt;&gt; registry.register_child_classes(dict)\n&gt;&gt;&gt; registry.registered_names()\n{...}\n</code></pre>"},{"location":"refs/registry/#objectory.registry.Registry.register_object","title":"objectory.registry.Registry.register_object","text":"<pre><code>register_object(\n    obj: type | Callable, name: str | None = None\n) -&gt; None\n</code></pre> <p>Register an object.</p> <p>Please read the documentation for more information.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>type | Callable</code> <p>Specifies the object to register. The object is expected to be a class or a function.</p> required <code>name</code> <code>str | None</code> <p>Specifies the name to use to register the object. If <code>None</code>, the full name of the object is used as name.</p> <code>None</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from objectory import Registry\n&gt;&gt;&gt; registry = Registry()\n&gt;&gt;&gt; class ClassToRegister:\n...     pass\n...\n&gt;&gt;&gt; registry.register_object(ClassToRegister)\n&gt;&gt;&gt; registry.registered_names()\n{'....ClassToRegister'}\n&gt;&gt;&gt; def function_to_register(*args, **kwargs):\n...     pass\n...\n&gt;&gt;&gt; registry.register_object(function_to_register)\n&gt;&gt;&gt; registry.registered_names()\n{...}\n</code></pre>"},{"location":"refs/registry/#objectory.registry.Registry.registered_names","title":"objectory.registry.Registry.registered_names","text":"<pre><code>registered_names(include_registry: bool = True) -&gt; set[str]\n</code></pre> <p>Get the names of all the registered objects.</p> <p>Parameters:</p> Name Type Description Default <code>include_registry</code> <code>bool</code> <p>Specifies if the other (sub-)registries should be included in the set. By default, the other (sub-)registries are included.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>set</code> <code>set[str]</code> <p>The names of the registered objects.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from objectory import Registry\n&gt;&gt;&gt; registry = Registry()\n&gt;&gt;&gt; registry.registered_names()\n&gt;&gt;&gt; # Show name of all the registered objects except the sub-registries.\n&gt;&gt;&gt; registry.registered_names(include_registry=False)\n</code></pre>"},{"location":"refs/registry/#objectory.registry.Registry.set_class_filter","title":"objectory.registry.Registry.set_class_filter","text":"<pre><code>set_class_filter(cls: type | None) -&gt; None\n</code></pre> <p>Set the class filter so only the child classes of this class can be registered.</p> <p>If you set this filter, you cannot register functions. To unset this filter, you can use <code>set_class_filter(None)</code>.</p> <p>Parameters:</p> Name Type Description Default <code>cls</code> <code>type | None</code> <p>Specifies the class to use as filter. Only the child classes of this class can be registered.</p> required <p>Raises:</p> Type Description <code>TypeError</code> <p>if the input is not a class or <code>None</code>.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from collections import Counter, OrderedDict\n&gt;&gt;&gt; from objectory import Registry\n&gt;&gt;&gt; registry = Registry()\n&gt;&gt;&gt; registry.mapping.set_class_filter(dict)\n&gt;&gt;&gt; registry.mapping.register_object(OrderedDict)\n&gt;&gt;&gt; registry.mapping.registered_names()\n{'collections.OrderedDict'}\n</code></pre>"},{"location":"refs/registry/#objectory.registry.Registry.unregister","title":"objectory.registry.Registry.unregister","text":"<pre><code>unregister(name: str) -&gt; None\n</code></pre> <p>Remove a registered object.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Specifies the name of the object to remove. This function uses the name resolution mechanism to find the full name if only the short name is given.</p> required <p>Raises:</p> Type Description <code>UnregisteredObjectFactoryError</code> <p>if the name does not exist in the registry.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from objectory import Registry\n&gt;&gt;&gt; from collections import Counter\n&gt;&gt;&gt; registry = Registry()\n&gt;&gt;&gt; registry.register_object(Counter)\n&gt;&gt;&gt; registry.unregister(\"collections.Counter\")\n</code></pre>"},{"location":"refs/utils/","title":"Utils","text":""},{"location":"refs/utils/#objectory.utils","title":"objectory.utils","text":"<p>Contain some utility functions or helpers.</p>"},{"location":"refs/utils/#objectory.utils.all_child_classes","title":"objectory.utils.all_child_classes","text":"<pre><code>all_child_classes(cls: type) -&gt; set[type]\n</code></pre> <p>Get all the child classes (or subclasses) of a given class.</p> <p>Based on: https://stackoverflow.com/a/3862957</p> <p>Parameters:</p> Name Type Description Default <code>cls</code> <code>type</code> <p>Specifies the class whose child classes you want to get.</p> required <p>Returns:</p> Type Description <code>set[type]</code> <p>The set of all the child classes of the given class.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from objectory.utils import all_child_classes\n&gt;&gt;&gt; class Foo:\n...     pass\n...\n&gt;&gt;&gt; all_child_classes(Foo)\nset()\n&gt;&gt;&gt; class Bar(Foo):\n...     pass\n...\n&gt;&gt;&gt; all_child_classes(Foo)\n{&lt;class '....Bar'&gt;}\n</code></pre>"},{"location":"refs/utils/#objectory.utils.full_object_name","title":"objectory.utils.full_object_name","text":"<pre><code>full_object_name(obj: Any) -&gt; str\n</code></pre> <p>Compute the full name of an object.</p> <p>This function works for class and function objects.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>Any</code> <p>Specifies the class/function that you want to compute the full name.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The full name of the object.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>if the object is not a class or a function.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from objectory.utils import full_object_name\n&gt;&gt;&gt; class MyClass:\n...     pass\n...\n&gt;&gt;&gt; full_object_name(MyClass)\n'....MyClass'\n&gt;&gt;&gt; def my_function():\n...     pass\n...\n&gt;&gt;&gt; full_object_name(my_function)\n'....my_function'\n</code></pre>"},{"location":"refs/utils/#objectory.utils.import_object","title":"objectory.utils.import_object","text":"<pre><code>import_object(object_path: str) -&gt; Any\n</code></pre> <p>Import an object given its path.</p> <p>This function can be used to dynamically import a class or a function. The object path should have the following structure: <code>module_path.object_name</code>. This function returns <code>None</code> if the object path does not respect this structure.</p> <p>Parameters:</p> Name Type Description Default <code>object_path</code> <code>str</code> <p>Specifies the path of the object to import.</p> required <p>Returns:</p> Type Description <code>Any</code> <p>The object if the import was successful otherwise <code>None</code>.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from objectory.utils import import_object\n&gt;&gt;&gt; obj = import_object(\"collections.Counter\")\n&gt;&gt;&gt; obj()\nCounter()\n&gt;&gt;&gt; fn = import_object(\"math.isclose\")\n&gt;&gt;&gt; fn(1, 1)\nTrue\n</code></pre>"},{"location":"refs/utils/#objectory.utils.instantiate_object","title":"objectory.utils.instantiate_object","text":"<pre><code>instantiate_object(\n    obj: Callable | type,\n    *args: Any,\n    _init_: str = \"__init__\",\n    **kwargs: Any\n) -&gt; Any\n</code></pre> <p>Instantiate dynamically an object from its configuration.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>Callable | type</code> <p>Specifies the class to instantiate or the function to call.</p> required <code>*args</code> <code>Any</code> <p>Variable length argument list.</p> <code>()</code> <code>_init_</code> <code>str</code> <p>Specifies the function to use to create the object. This input is ignored if <code>obj</code> is a function. If <code>\"__init__\"</code>, the object is created by calling the constructor.</p> <code>'__init__'</code> <code>**kwargs</code> <code>Any</code> <p>Arbitrary keyword arguments.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Any</code> <p>The instantiated object if <code>obj</code> is a class name, otherwise the returned value of the function.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>if <code>obj</code> is not a class or a function.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from collections import Counter\n&gt;&gt;&gt; from objectory.utils import instantiate_object\n&gt;&gt;&gt; instantiate_object(Counter, [1, 2, 1])\nCounter({1: 2, 2: 1})\n&gt;&gt;&gt; instantiate_object(list, [1, 2, 1])\n[1, 2, 1]\n</code></pre>"},{"location":"refs/utils/#objectory.utils.is_lambda_function","title":"objectory.utils.is_lambda_function","text":"<pre><code>is_lambda_function(obj: Any) -&gt; bool\n</code></pre> <p>Indicate if the object is a lambda function or not.</p> <p>Adapted from https://stackoverflow.com/a/23852434</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>Any</code> <p>Specifies the object to check.</p> required <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the input is a lambda function, otherwise <code>False</code></p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from objectory.utils import is_lambda_function\n&gt;&gt;&gt; is_lambda_function(lambda value: value + 1)\nTrue\n&gt;&gt;&gt; def my_function(value: int) -&gt; int:\n...     return value + 1\n...\n&gt;&gt;&gt; is_lambda_function(my_function)\nFalse\n&gt;&gt;&gt; is_lambda_function(1)\nFalse\n</code></pre>"},{"location":"refs/utils/#objectory.utils.is_object_config","title":"objectory.utils.is_object_config","text":"<pre><code>is_object_config(config: dict, cls: type) -&gt; bool\n</code></pre> <p>Indicate if the input configuration is a configuration for a given class.</p> <p>This function only checks if the value of the key  <code>_target_</code> is valid. It does not check the other values. If <code>_target_</code> indicates a function, the returned type hint is used to check the class.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>dict</code> <p>Specifies the configuration to check.</p> required <code>cls</code> <code>type</code> <p>Specifies the object class.</p> required <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the input configuration is a configuration for the given class.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from objectory.utils import is_object_config\n&gt;&gt;&gt; from collections import Counter\n&gt;&gt;&gt; is_object_config({\"_target_\": \"collections.Counter\", \"iterable\": [1, 2, 1, 3]}, Counter)\nTrue\n</code></pre>"},{"location":"refs/utils/#objectory.utils.resolve_name","title":"objectory.utils.resolve_name","text":"<pre><code>resolve_name(\n    name: str,\n    object_names: set[str],\n    allow_import: bool = True,\n) -&gt; str | None\n</code></pre> <p>Find a match of the query name in the set of object names.</p> <p>The resolution is successful only if there is only one object name that can match with the query name. Please read the documentation to learn more about the name resolution mechanism.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Specifies the query name to use to find a match in the set of object names.</p> required <code>object_names</code> <code>set[str]</code> <p>Specifies the set of object names.</p> required <code>allow_import</code> <code>bool</code> <p>If <code>True</code>, the parent package is installed if it was not imported previously.</p> <code>True</code> <p>Returns:</p> Type Description <code>str | None</code> <p>The resolved name if the resolution was successful, otherwise <code>None</code></p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from objectory.utils import resolve_name\n&gt;&gt;&gt; resolve_name(\"OrderedDict\", {\"collections.OrderedDict\", \"collections.Counter\"})\ncollections.OrderedDict\n&gt;&gt;&gt; resolve_name(\"objectory.utils.resolve_name\", {\"math.isclose\"})\n'objectory.utils.name_resolution.resolve_name'\n&gt;&gt;&gt; resolve_name(\"OrderedDict\", {\"collections.Counter\", \"math.isclose\"})\nNone\n</code></pre>"}]}